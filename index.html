<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="小笨熊的旅途">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小笨熊的旅途">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小笨熊的旅途">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>小笨熊的旅途</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小笨熊的旅途</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/30/重新认识flex缩写属性—[flex]/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/30/重新认识flex缩写属性—[flex]/" itemprop="url">重新认识flex缩写属性—[flex]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T06:54:56+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="flex-1引发的疑惑"><a href="#flex-1引发的疑惑" class="headerlink" title="flex:1引发的疑惑"></a>flex:1引发的疑惑</h2><p>&emsp;&emsp;flex是flex-grow,flex-shrink,flex-basis三个属性值的缩写，所以我也曾以为只是单纯缩写而已，没什么复杂的，直到看了flex:1能实现各子元素均分外层容器空间的效果：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex17.png"></image></div><br><div align="center">图1</div>

<p>&emsp;&emsp;html和css代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner&quot;&gt;我是左侧的item&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;inner&quot;&gt;我是右侧的item,我的内容比较多&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.container&#123;</span><br><span class="line">     height:300px;</span><br><span class="line">     width:400px;</span><br><span class="line">     border:1px solid red;</span><br><span class="line">     display:flex;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> .inner&#123;</span><br><span class="line">     border:1px solid black;</span><br><span class="line">     flex:1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;按照我最初的理解，flex:1相当于设置了flex-grow:1,flex-shrink:1(默认值),flex-basis:auto(默认值)，而如果对元素这样设置三个属性值的话，效果如下图2所示，明显是水平均分的，因为flex-grow为1只是表示均分多余的空间</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex18.png"></image></div><br><div align="center">图2</div>

<p>&emsp;&emsp;那么问题来了，flex:1并不等价于flex-grow:1,flex-shrink:1(默认值),flex-basis:auto啊，说好的缩写呢？</p>
<h2 id="flex是缩写"><a href="#flex是缩写" class="headerlink" title="flex是缩写"></a>flex是缩写</h2><p>&emsp;&emsp;flex是flex-grow,flex-shrink和flex-basis的缩写，flex属性值可以只指定一个属性的值，而另外的属性值采用各自在flex属性中的的初始值，但是有一点要注意的是：flex属性中flex-grow和flex-basis的初始值和它们原始的默认值不同，至于为什么不同，mdn中有明确的说过<code>这样的设计是为了让「flex」缩写在最常见的情景下比较好用。</code></p>
<h2 id="flex中对应各属性的初始值"><a href="#flex中对应各属性的初始值" class="headerlink" title="flex中对应各属性的初始值"></a>flex中对应各属性的初始值</h2><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>&emsp;&emsp;flex-grow用于设置各item项按对应比例划分剩余空间，若flex中没有指定flex-grow,则相当于设置了flex-grow:1</p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>&emsp;&emsp;flex-shrink用于设置item的总和超出容器空间时，各item的收缩比例，若flex中没有指定flex-shrink,则等同于设置了flex-shrink:1</p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>&emsp;&emsp;flex-basis用于设置各item项的伸缩基准值，可以取值为长度或百分比，如果flex中省略了该属性，则相当于设置了flex-basis:0.</p>
<h2 id="flex的不同取值"><a href="#flex的不同取值" class="headerlink" title="flex的不同取值"></a>flex的不同取值</h2><p>&emsp;&emsp;flex的值的完整写法是[\<flex-grow> \<flex-shrink> \<flex-basis>],不过它的取值还有可能是单个数字或者单个百分比等，不同种类的取值所表示的意思是大有不同的。</flex-basis></flex-shrink></flex-grow></p>
<h3 id="flex值为none"><a href="#flex值为none" class="headerlink" title="flex值为none"></a>flex值为none</h3><p>&emsp;&emsp;当flex为none时,等同于flex: 0 0 auto;</p>
<h3 id="flex值为auto"><a href="#flex值为auto" class="headerlink" title="flex值为auto"></a>flex值为auto</h3><p>&emsp;&emsp;当flex为auto时，等同于flex: 1 1 auto;</p>
<h3 id="flex值为一个非负数字"><a href="#flex值为一个非负数字" class="headerlink" title="flex值为一个非负数字"></a>flex值为一个非负数字</h3><p>&emsp;&emsp;当flex取值为一个数字，则该数字是设置的flex-grow值，其它两个属性用初始值，如flex:1时，等同于flex: 1 1 0%</p>
<h3 id="flex值为两个非负数字"><a href="#flex值为两个非负数字" class="headerlink" title="flex值为两个非负数字"></a>flex值为两个非负数字</h3><p>&emsp;&emsp;当flex取值为2个数字时，相当于设置的flex-grow和flex-shrink值，flex-basis取值为初始值，如flex:1 0时，等同于flex: 1 0 0%</p>
<h3 id="flex值为一个数字和一个长度或百分比时"><a href="#flex值为一个数字和一个长度或百分比时" class="headerlink" title="flex值为一个数字和一个长度或百分比时"></a>flex值为一个数字和一个长度或百分比时</h3><p>&emsp;&emsp;当flex取值为1个数字和1个长度或百分比时，设置的是flex-grow和flex-basis的值，flex-shrink值时初始值，如flex:1 20%,等同于flex: 1 1 20%</p>
<p>&emsp;&emsp;原来一个简单的缩写属性flex是有这么多花样的~那么我不想背它的初始值，不同值对应的缩放属性等等，有这么多原因，以后是不是不用flex就可以了，光明正大用flex-grow,flex-shrink,flex-basis就好了？当然是可以了~不过用flex至少还是有它的好处的，比如说看上去简洁(一个flex属性能有这么多不同效果进而显得高大上),还有重要的一点，同样的一个单词能完成三个单词的工作，能使代码少啊:）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/29/进一步了解flex布局—来实现这些常见布局吧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/29/进一步了解flex布局—来实现这些常见布局吧/" itemprop="url">进一步了解flex布局—来实现这些常见布局吧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-29T07:03:10+08:00">
                2018-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;flex布局具有便捷、灵活的特点，熟练的运用flex布局能解决大部分布局问题，这里对一些常用布局场景做一些总结。</p>
<h2 id="web页面布局-topbar-main-footbar"><a href="#web页面布局-topbar-main-footbar" class="headerlink" title="web页面布局(topbar + main + footbar)"></a>web页面布局(topbar + main + footbar)</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>&emsp;&emsp;要实现的效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex11.png"></image></div><br><div align="center">图1</div>

<p>&emsp;&emsp;html代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;header...&lt;/header&gt;</span><br><span class="line">  &lt;main&gt;内容&lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;footer...&lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;css代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">header&#123;</span><br><span class="line">  height:100px;</span><br><span class="line">  background:#ccc;</span><br><span class="line">&#125;</span><br><span class="line">footer&#123;</span><br><span class="line">  height:100px;</span><br><span class="line">  background:#ccc;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-direction:column;</span><br><span class="line">  height:100vh;</span><br><span class="line">&#125;</span><br><span class="line">main&#123;</span><br><span class="line">  flex-grow:1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用的flex属性"><a href="#应用的flex属性" class="headerlink" title="应用的flex属性"></a>应用的flex属性</h3><p>&emsp;&emsp;本例中主要应用了以下flex属性：</p>
<ol>
<li>flex-direction:column 使整体布局从上到下排列</li>
<li>flex-grow:1, 应用于main，使得main自动填充剩余空间</li>
</ol>
<p>本例中应用以较少的css代码实现了传统的上中下页面布局，其中的关键通过flex-grow的使用避免了当main内容过少时footer部分会被提升到页面上方的问题(传统方式上可能需要靠绝对定位来解决了~)</p>
<h2 id="每行的项目数固定并自动换行的列表项"><a href="#每行的项目数固定并自动换行的列表项" class="headerlink" title="每行的项目数固定并自动换行的列表项"></a>每行的项目数固定并自动换行的列表项</h2><p>&emsp;&emsp;要实现的效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex12.png"></image></div><br><div align="center">图2</div>

<p>&emsp;&emsp;html代码：</p>
<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><p>&emsp;&emsp;css代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-wrap:wrap;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">  list-style:none;</span><br><span class="line">  flex:0 0 25%;</span><br><span class="line">  background:#ddd;</span><br><span class="line">  height:100px;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用的flex属性-1"><a href="#应用的flex属性-1" class="headerlink" title="应用的flex属性"></a>应用的flex属性</h3><p>&emsp;&emsp;本例中主要应用了以下flex属性：</p>
<ol>
<li><p>flex:0 0 25%,相当于flex-basis:25%，使得每一个列表项的宽度占外层容器(本例中的ul元素)的25%，因此每行最多能够排开四个列表项。</p>
</li>
<li><p>flex-wrap:wrap,使得每行填满时会自动换行</p>
</li>
</ol>
<h2 id="实现自动划分多余空间的列表项"><a href="#实现自动划分多余空间的列表项" class="headerlink" title="实现自动划分多余空间的列表项"></a>实现自动划分多余空间的列表项</h2><p>&emsp;&emsp;本例的效果和上例中的图2很相似，只是每行为3个固定宽度的列表项，并且各列表项之间留有相同宽度的空隙</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex13.png"></image></div><br><div align="center">图3</div>

<p>&emsp;&emsp;传统方式上实现这种效果，不可避免的要用到负margin，那么现在来看了用flex实现的方式吧</p>
<h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><p>&emsp;&emsp;css代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-wrap:wrap;</span><br><span class="line">  justify-content:space-between;</span><br><span class="line">  border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">  list-style:none;</span><br><span class="line">  width:120px;</span><br><span class="line">  background:#ddd;</span><br><span class="line">  height:100px;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用的flex属性-2"><a href="#应用的flex属性-2" class="headerlink" title="应用的flex属性"></a>应用的flex属性</h3><p>&emsp;&emsp;本例中主要应用了以下flex属性：</p>
<ol>
<li>justify-content:space-between;使主轴方向的多余空间平均分配在两两item之间</li>
</ol>
<h2 id="平均分配空间的栅格布局"><a href="#平均分配空间的栅格布局" class="headerlink" title="平均分配空间的栅格布局"></a>平均分配空间的栅格布局</h2><p>&emsp;&emsp;各大UI里栅格布局基本是必备的布局之一，平均分配布局又是栅格布局里最常用的布局，利用flex实现平均分配的栅格布局，关键之处就是利用它的自动收缩空间。</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex14.png"></image></div><br><div align="center">图4</div>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>&emsp;&emsp;html如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;row&quot;&gt;</span><br><span class="line">         &lt;div class=&quot;column&quot;&gt;column1&lt;/div&gt;</span><br><span class="line">         &lt;div  class=&quot;column&quot;&gt;colum22&lt;/div&gt;</span><br><span class="line">         &lt;div  class=&quot;column&quot;&gt;colum322&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.row&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  flex-wrap:wrap;</span><br><span class="line">  border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.column&#123;</span><br><span class="line">  list-style:none;</span><br><span class="line">  background:#ddd;</span><br><span class="line">  flex:1;</span><br><span class="line">  height:100px;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用的flex属性-3"><a href="#应用的flex属性-3" class="headerlink" title="应用的flex属性"></a>应用的flex属性</h3><p>&emsp;&emsp;本例中主要应用了以下flex属性：</p>
<ol>
<li>flex:1 这里针对item应用了flex:1,相当于flex:1 1 0%,而之所以不管各个column元素内容的宽度为多大，都能均分到相等的空间，正式因为相当于在设置了flex-grow:1使得剩余空间按相等比例自动分配的同时又设置了flex-basis:0%,才使得整个空间都平均分配了。</li>
</ol>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>&emsp;&emsp;传统的圣杯布局需要涉及绝对定位、浮动、负margin等几大最头疼属性，有了flex布局以后发现，原来这么简单的配方，也能实现这么复杂的效果哈~</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex15.png"></image></div><br><div align="center">图5 圣杯布局</div>

<h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><p>&emsp;&emsp;html代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">       &lt;main&gt;main&lt;/main&gt;</span><br><span class="line">       &lt;aside&gt;aside&lt;/aside&gt;</span><br><span class="line">       </span><br><span class="line">       &lt;nav&gt;nav&lt;/nav&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;css代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  height:100vh;</span><br><span class="line">&#125;</span><br><span class="line">aside&#123;</span><br><span class="line">  width:50px;</span><br><span class="line">  background:#ccc;</span><br><span class="line">&#125;</span><br><span class="line">main&#123;</span><br><span class="line">  flex-grow:1;</span><br><span class="line">  background:#def;</span><br><span class="line">&#125;</span><br><span class="line">nav&#123;</span><br><span class="line">  width:80px;</span><br><span class="line">  background:#ccc;</span><br><span class="line">  order:-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用的flex属性-4"><a href="#应用的flex属性-4" class="headerlink" title="应用的flex属性"></a>应用的flex属性</h3><ol>
<li>对main用flex-grow:1,使得中间主元素空间自动扩充</li>
<li>对nav应用order:-1,使得order处于最左侧(html中main写在了最前，以利于优先加载主内容区)</li>
</ol>
<h2 id="元素水平垂直居中"><a href="#元素水平垂直居中" class="headerlink" title="元素水平垂直居中"></a>元素水平垂直居中</h2><p>&emsp;&emsp;如何让一个元素同时水平垂直居中？答案很多样也很复杂，但是在这么多样化得答案中flex绝对是最简单的一种了~</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex16.png"></image></div><br><div align="center">图6 水平垂直居中</div>

<h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><p>&emsp;&emsp;html代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;inner&quot;&gt;我是中间的内容&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;css代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  height:300px;</span><br><span class="line">  width:300px;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content:center;</span><br><span class="line">  align-items:center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.inner&#123;</span><br><span class="line">  border:1px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用的flex属性-5"><a href="#应用的flex属性-5" class="headerlink" title="应用的flex属性"></a>应用的flex属性</h3><ol>
<li>justify-content:center;使item元素水平居中</li>
<li>align-items:center;使item元素垂直居中</li>
</ol>
<p>&emsp;&emsp;这么多场景都难不倒flex有木有，果然名不虚传~(&emsp;&emsp;想更详细的了解flex相关属性的话，请戳<a href="https://juejin.im/post/5b0d6eab6fb9a009ea104bdd" target="_blank" rel="noopener">flex入门—了解这些flex属性</a>~)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/flex入门—了解这些flex属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/24/flex入门—了解这些flex属性/" itemprop="url">flex入门—了解这些flex属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T07:13:39+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="传统的页面布局"><a href="#传统的页面布局" class="headerlink" title="传统的页面布局"></a>传统的页面布局</h2><p>&emsp;&emsp;在flex出现之前，双列布局，三列布局，动态盒居中,绝对居中布局等常见的布局均是采用dispaly+float+定位来布局的，一般包括以下几种布局策略：</p>
<ol>
<li>normal flow(文档流:块级元素从上到下，行内元素从左到右)</li>
<li>float + clear</li>
<li>position relative + absolute</li>
<li>display inline-block</li>
<li>负margin(扩大宽度，产生位移，如一行里的多个column)</li>
</ol>
<h2 id="flex来了"><a href="#flex来了" class="headerlink" title="flex来了"></a>flex来了</h2><p>&emsp;&emsp;flex-即flexible,弹性的，灵活的，又叫弹性盒布局(flexible box layout)，这种布局方式主要有以下特点：</p>
<ol>
<li>块级布局侧重垂直方向，行内布局侧重水平方向，而flex是与方向无关的(来源于后续提到的一个重要属性flex-direction)</li>
<li>flex布局可以实现空间自动分配、自动对齐(弹性灵活的体现，与后续提到的flex-grow,flex-shrink，flex-basis属性有很大关系)</li>
<li>flex适用于简单的线性布局(左右或上下布局)，更复杂的布局需要用grid布局(如瀑布流布局)<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex0.png"></image></div>

</li>
</ol>
<p>&emsp;&emsp;关于flex布局中，有以下几个基本常识值得注意：</p>
<ol>
<li>如图所示flex布局中有两条轴线贯穿了外层容器，分别为主轴和侧轴(这里主轴不一定是水平方向的轴线，具体有flex-direction而定，即主轴和侧轴的方向是不一定的，也印证了flex布局是方向无关的)</li>
<li>主轴的尺寸为main size,侧轴的尺寸为cross size</li>
<li>主轴的起点和终点分别为main start和main end,对应的侧轴的起点和终点分别为cross start和cross end</li>
<li>应用了<code>display:flex</code>属性的元素叫做 flex container，即flex容器，它里面的子元素叫做flex item</li>
<li>flex 容器的<code>宽度总是自动扩张到最大值</code>(注意是宽度，不管主轴是哪个方向，它的宽度总是会扩张到最大值,即使这个容器元素是行内元素如span,而子元素的宽度受多个属性影响，如flex-direction,align-items,flex-grow等，有时候看起来容器元素的宽度并不等于item元素宽度的和，如下图2所示)</li>
<li>flex 容器内的子元素即flex-item在不指定height,width的情况下总是自动收缩的(height本来就自动收缩，但当父元素display:flex后，这些子元素的宽度也都自动收缩，而没有了原本块级元素在宽度上自动扩张的特性)，同样的，这里<code>不区分主轴的方向，height,width总是自动收缩</code></li>
<li>display:flex以后 float,clear,vertical-align等属性均失效</li>
</ol>
<h2 id="flex-container的六大属性"><a href="#flex-container的六大属性" class="headerlink" title="flex container的六大属性"></a>flex container的六大属性</h2><h3 id="flex-direction—方向"><a href="#flex-direction—方向" class="headerlink" title="flex-direction—方向"></a>flex-direction—方向</h3><p>&emsp;&emsp;flex-direction 指定了子元素排列的方式，可以为row(按行展示)/column(按列展示)/inherit/row-reverse/column-reverse</p>
<p>例1. 当flex-direction为row时，显示效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/05/25flex2.png"></image></div><br><div align="center">图2</div>

<p>其中html和css代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;item2&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.container&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">  height:300px;</span><br><span class="line">&#125;</span><br><span class="line">.item&#123;</span><br><span class="line">  border:1px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2.当为.container添加flex-direction:cloumn属性后，排列效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/05/25flex1.png"></image></div><br><div align="center">图3</div>

<p>&emsp;&emsp;图2，图3中的flex-item都没有指定width和height值，但我们通过border可以看到看到，图2中的垂直方向的空间自动填满了container的宽度，即container此时在主轴方向的长度，图3中的水平方向的空间自动填满了container的高度，同样的，这也是container此时在侧轴方向的长度，这个现在和后续提到的<code>align-items</code>有关，不过我们暂时可以做出如下总结：<br>默认情况下，flex-item元素在其侧轴方向的长度总是自动扩张的(当然，后续会知道，只是默认情况，稍微改变align-items属性值，表现就会不一样~)</p>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>&emsp;&emsp;用于控制是否可以换行(按row排列时)/列(按column排列时)，当flex-wrap是nowrap时，所有items总是自动缩小而不会换行(列)</p>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>&emsp;&emsp;flex-direction和flex-wrap的缩写，如flex:row wrap实际上同时设置了 flex-direction:row和flex-wrap:wrap;</p>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>&emsp;&emsp;主轴方向的对齐方式，可取:flex-start/flex-end/center/space-around/space-between,默认为flex-start</p>
<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>&emsp;&emsp;侧轴方向的对齐方式，可取：flex-start/flex-end/center/stretch/baseline,默认为stretch(填满父空间,<code>前提是不指定height值,当指定了height值时，会以该值为主</code>),也就是之前提到的<code>默认情况下，flex-item元素在其侧轴方向的长度总是自动扩张的</code></p>
<h4 id="align-itmes-stretch和height同时存在时"><a href="#align-itmes-stretch和height同时存在时" class="headerlink" title="align-itmes:stretch和height同时存在时"></a>align-itmes:stretch和height同时存在时</h4><p>&emsp;&emsp;为了测试指定height时，align-items：stretch还是否会对元素项产生效果，进行了以下测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div&gt;item1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item2&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item3&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item4&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">    align-items:stretch;</span><br><span class="line">&#125;</span><br><span class="line">.outer div:nth-child(1)&#123;</span><br><span class="line">  height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex9.png"></image></div>

<p>&emsp;&emsp;如图所示，由于align-items是stretch(也是默认值),所以除item1元素外的所有元素在侧轴方向都自动拉伸到最大了，而item1之所以没有自动拉伸，是因为对其显示设置了高度，此时可以理解为height属性的优先级要更高。</p>
<h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>&emsp;&emsp;align-content属性和justify-content，align-items是类似的，都是控制item元素之间的摆放方式，只是该属性只有在主轴方向上有多个轴线时才有效，如flex-direction是row时，如果item有换行则align-cnotent属性值有效，当flex-direction是clolumn时，如果item有换列，则align-content有效，其中属性值可以取flex-start/flex-end/center/space-around/space-between/stretch</p>
<blockquote>
<p>注意：justify-content是用于控制属于不同的主轴线(可以想象为平行与主轴线)的元素在侧轴方向的的排列方式，其属性值包含space-around/space-between，没有stretch,而align-items是用于控制单个元素在侧轴方向的摆放的，其属性值包含stretch,不含space-around/space-between，align-content则用于控制当同一个侧轴有多个元素时，这些元素之间的摆放方式，它们即可取space-around/space-between，又可取stretch(当每一个侧轴都只穿过一个元素时(即没有多个主轴线，没换行/列)，该属性失效)</p>
</blockquote>
<h4 id="align-content和align-items属性同时指定时"><a href="#align-content和align-items属性同时指定时" class="headerlink" title="align-content和align-items属性同时指定时"></a>align-content和align-items属性同时指定时</h4><p>&emsp;&emsp;以flex-direction:row时为例，当item有多行时，align-content和align-items是同时有效的，align-content控制行于行之间的排列关系，align-items控制元素在一行中的位置，可以看下以下例子：</p>
<p>html和css部分如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div&gt;item1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item2&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item3&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item4&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">  height:300px;</span><br><span class="line">  align-items:center;</span><br><span class="line">  flex-wrap:wrap;</span><br><span class="line">  align-content:flex-end;</span><br><span class="line">&#125;</span><br><span class="line">.outer div&#123;</span><br><span class="line">  width:200px;</span><br><span class="line">  border:1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">.outer div:nth-child(1)&#123;</span><br><span class="line">  height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下所示：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex4.jpg"></image></div><br><div align="center">图4</div>

<p>&emsp;&emsp;可以看到，现在item1和item2是处于一行的，item3和item4是处于一行的，由于align-content是flex-end,所以所有行依次排列在侧轴的终点处，同时由于align-items为center，所以item2处于它所在行的垂直方向的中点处(<strong>原来并非相对于它的父元素垂直居中，而是相对于它所在的行垂直居中</strong>)</p>
<p>&emsp;&emsp;接下来，再看一下把align-items:center去掉的效果</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex5.png"></image></div><br><div align="center">图5</div>

<p>&emsp;&emsp;如图5所示，和刚才不同的是，item2在没有指定高度的情况下自动拉伸为何item1的高度(指定了200px)一样了，其实还是因为align-items的效果，它虽然没有显示指定，但它的默认值是stretch，所以在它所处的行中在垂直方向自动拉伸了。</p>
<p>&emsp;&emsp;所以，当align-content有效时，不要以为align-items就无效了，只是它们的作用不同而已，一个控制不同行元素相对于父元素(flex-container)的排列方式，一个用于控制元素在所处行中的垂直方向的位置(这里指的flex-direction为row,flex-direction为column时请自行推算~)</p>
<h2 id="flex-item的六大属性"><a href="#flex-item的六大属性" class="headerlink" title="flex item的六大属性"></a>flex item的六大属性</h2><h3 id="flex-grow-多余空间自动分配比例"><a href="#flex-grow-多余空间自动分配比例" class="headerlink" title="flex-grow:多余空间自动分配比例"></a>flex-grow:多余空间自动分配比例</h3><p>&emsp;&emsp;用于控制当主轴方向空间过多时，元素在主轴方向的长度自动增加；如果多个元素同时指定了flex-grow，则<code>多余的空间</code>会按照各自flex-grow值的比例<code>自动分配</code></p>
<blockquote>
<p>默认值：0</p>
</blockquote>
<h3 id="flex-shrink-超出空间自动收缩比例"><a href="#flex-shrink-超出空间自动收缩比例" class="headerlink" title="flex-shrink:超出空间自动收缩比例"></a>flex-shrink:超出空间自动收缩比例</h3><p>&emsp;&emsp;当主轴方向空间不够时，使元素在主轴方向的长度自动收缩(即使为元素项设置了显示宽度width值，依然会根据需要自动收缩，不同于之前container中的align-items属性值stretch会低于height的优先级)，以使得总长度能够适应container的长度(当应用了flex-wrap:wrap时，一般是不会自动收缩的，因为这时候自动换行/列了，不会空间不够)</p>
<blockquote>
<p>默认值：1</p>
</blockquote>
<h4 id="flex-shrink和flex-wrap配合使用"><a href="#flex-shrink和flex-wrap配合使用" class="headerlink" title="flex-shrink和flex-wrap配合使用"></a>flex-shrink和flex-wrap配合使用</h4><p>&emsp;&emsp;flex-shrink的概念已经明了，看上去功能比较单一，不过不同的属性值之间的搭配还是会带来很多样化得效果的，尤其是这里就来看一下flex-shrink和flex-wrap的配合使用。</p>
<h5 id="flex-shrink-0和flex-wrap-nowrap"><a href="#flex-shrink-0和flex-wrap-nowrap" class="headerlink" title="flex-shrink:0和flex-wrap:nowrap"></a>flex-shrink:0和flex-wrap:nowrap</h5><p>&emsp;&emsp;下面看一下flex-shrink为0并且container没有设置flex-wrap属性时的效果:</p>
<p>&emsp;&emsp;html和css如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">    &lt;div&gt;item1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item2&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item3&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;item4&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  border:1px solid red;</span><br><span class="line">  height:300px;</span><br><span class="line">  align-content:flex-end;</span><br><span class="line">&#125;</span><br><span class="line">.outer div&#123;</span><br><span class="line">  width:150px;</span><br><span class="line">  </span><br><span class="line">  border:1px solid black;</span><br><span class="line">  flex-shrink:0;</span><br><span class="line">&#125;</span><br><span class="line">.outer div:nth-child(1)&#123;</span><br><span class="line">  height:200px;</span><br><span class="line">&#125;</span><br><span class="line">.outer div:nth-child(2)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex6.png"></image></div><br><div align="center">图6</div>

<p>&emsp;&emsp;如上图所示，当设置item的flex-shrink为0时，说明子元素项不会自动收缩，造成的结果就是所有元素项按自身原本的尺寸依次排列，可能会有主轴上总长度超出container在该放向的长度的可能。</p>
<h5 id="flex-shrink-1和flex-wrap-nowrap"><a href="#flex-shrink-1和flex-wrap-nowrap" class="headerlink" title="flex-shrink:1和flex-wrap:nowrap"></a>flex-shrink:1和flex-wrap:nowrap</h5><p>&emsp;&emsp;接下来，将css中设置的flex-shrink:0去掉(等同于设置了flex-shrink:1,因为这是默认值)，此时效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex7.png"></image></div><br><div align="center">图7</div>

<p>&emsp;&emsp;如上图所示，此时，各子元素项的宽度(在主轴方向的长度)明显收缩了(小于为其设置的width:150px)，这就是因为默认的flex-shrink:1使得超出的部分均分在了所有子元素项的宽度上。</p>
<h5 id="flex-shrink-1和flex-wrap-wrap"><a href="#flex-shrink-1和flex-wrap-wrap" class="headerlink" title="flex-shrink:1和flex-wrap:wrap"></a>flex-shrink:1和flex-wrap:wrap</h5><p>&emsp;&emsp;最后，再为container添加flex-wrap:wrap看下是否又会有什么不同呢？</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex8.png"></image></div><br><div align="center">图8</div>

<p>&emsp;&emsp;如图8所示，此时子元素项懂得在合适的位置自动换行了，因此也就不存在宽度超出父元素宽度范围的情况了，所以即使设置了flex-shrink也不会出现长度收缩了~</p>
<h3 id="flex-basis-原始大小"><a href="#flex-basis-原始大小" class="headerlink" title="flex-basis 原始大小"></a>flex-basis 原始大小</h3><p>&emsp;&emsp;我们都知道为container设置了display:flex后，子元素项的宽度正是恰好包裹自身内容的宽度，相当于是自动的，设置flex-basis后则类似于设置了width值，可以显示指定宽度，取值可以为绝对单位或是百分比(可用于栅格效果)</p>
<blockquote>
<p>默认值：auto</p>
</blockquote>
<h3 id="flex-缩写"><a href="#flex-缩写" class="headerlink" title="flex 缩写"></a>flex 缩写</h3><p>&emsp;&emsp;flex属性即为flex-grow,flex-shrink,flex-basis三个属性的缩写</p>
<h3 id="order-指定次序"><a href="#order-指定次序" class="headerlink" title="order 指定次序"></a>order 指定次序</h3><p>&emsp;&emsp;order用于指定子元素项在兄弟元素中排列的顺序，应用该属性可以简单的实现双飞翼布局</p>
<h3 id="align-self-自身的对齐方式-特殊化自身元素"><a href="#align-self-自身的对齐方式-特殊化自身元素" class="headerlink" title="align-self 自身的对齐方式(特殊化自身元素)"></a>align-self 自身的对齐方式(特殊化自身元素)</h3><p>&emsp;&emsp;align-self指定元素自身在侧轴上的对齐方式，可以用来<code>覆盖align-items属性的值对自身设置的效果</code>。</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/flex10.png"></image></div><br><div align="center">图9</div>

<p>&emsp;&emsp;如图9所示，当align-items为stretch，item1的align-slef为center时，除item1外的所有元素在侧轴方向的对齐方式都是自动延伸的，而item1元素因为应用了align-slef:center,明显是垂直居中的。</p>
<p>&emsp;&emsp;想了解不同布局的flex实现方式的话，请戳<a href="https://juejin.im/post/5b0d6ca76fb9a009fd0e9329" target="_blank" rel="noopener">进一步了解flex布局—来实现这些常见布局吧</a>~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/立即执行函数和闭包/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/立即执行函数和闭包/" itemprop="url">立即执行函数和闭包再总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T22:40:42+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;我们常常听到别人问:什么是立即执行函数？什么是闭包？它们有什么联系？它们的作用是什么？最近刚好对这个问题有些思考，这里就做一下下总结</p>
<h2 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h2><p>&emsp;&emsp;要说什么是立即函数，顾名思义，立即执行的函数呗，那么为什么要用立即执行函数呢？这就要从一个老生常谈的问题说起了</p>
<h3 id="变量污染"><a href="#变量污染" class="headerlink" title="变量污染"></a>变量污染</h3><p>&emsp;&emsp;我们知道，所有在函数外定义的变量都是全局变量，而全局变量多了，难免不出现一不小心被覆盖的问题，尤其是在多人合作开发的项目中，可以想象每个人在写自己的模块的代码时都定义一堆全局变量，一旦出现被覆盖的问题，极有可能引发大的bug<br>&emsp;&emsp;那么，怎么解决全局变量带来的变量污染的问题呢？简单啦，不用全局变量就可以啦 </p>
<h3 id="局部变量替代全局变量"><a href="#局部变量替代全局变量" class="headerlink" title="局部变量替代全局变量"></a>局部变量替代全局变量</h3><p>&emsp;&emsp;为了杜绝变量污染，我们选择抛弃全局变量，而只用局部变量，而ES5中，只有函数中用var 声明的变量才是局部变量，(ES6中{},新增了块级作用域，代码块中用let定义的变量也是局部变量，但这里为了通用，不考虑ES6),所以我们必须将所有变量的初始化和赋值都在函数作用域内进行。</p>
<h4 id="函数的引入"><a href="#函数的引入" class="headerlink" title="函数的引入"></a>函数的引入</h4><p>&emsp;&emsp;我们在函数中进行变量相关的所有操作，但是函数仅仅声明的话是没有用的，必须要调用，它的代码才会被执行，它自身的定义才有意义，像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function abc()&#123;</span><br><span class="line">    var a=1;</span><br><span class="line">    var b=2;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line">abc()；</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，这种方式不可避免的是至少有一个变量依然会是全局变量，即函数名称，因为函数终究会被调用，所以我们要给它起一个名字，否则不知道名字怎么调用它呢？等等等，不知道名字也能调用啊，匿名函数就是啦</p>
<h4 id="立即调用的匿名函数"><a href="#立即调用的匿名函数" class="headerlink" title="立即调用的匿名函数"></a>立即调用的匿名函数</h4><p>&emsp;&emsp;匿名函数时可以调用的，这个我们都知道的，只不过一开始对匿名函数的调用方式总是混淆，比如说以下几种方式，哪几种是对的，哪几种是错的？ </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. function()&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">2. (function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">3. (function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;())</span><br><span class="line">4. !function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br><span class="line">5. ~function()&#123;</span><br><span class="line"></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;稍微有一点点经验的可能会肯定的说1，4,5是错的，2,4是对的(因为书上这么教我滴)，但不好意思，答错啦，可能是那本书只教了一半吧，事实上，除了1以外，其它几种方法都是正确的。</p>
<p>&emsp;&emsp;为什么是这样呢？应该是和浏览器的解析机制有关吧，它认为，如果是单独的<code>function(){}()</code>这样的形式，不能确定你是想调用函数，会报语法的错误，但是当你加了<code>()</code>,<code>~</code>,<code>!</code>等符号会，它会认为这是一个表达式，会把后<code>()</code>看到是在调用，会顺利的帮你执行这个函数(可以试试<code>+</code>,<code>-</code>等符号，有惊喜)</p>
<p>&emsp;&emsp;到这里发现了，立即调用的匿名函数就是立即执行函数啦(匿名函数还可以作为参数传入后被调用，这个就与我们说的立即执行函数无关啦)</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&emsp;&emsp;纯粹的立即执行函数大多数情况下回面临一个问题，就是我想让这个函数里的信息和其它模块之间能够交互，该怎么办呢(在模块开发中，这很常见的，几乎不可能让各模块之间毫无交流)？解决这个问题又两个办法：</p>
<blockquote>
<p>1.在函数中将需要提供给外界的接口作为属性值赋值给window对象，像下面这样： </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">    ...</span><br><span class="line">    window.a=&#123;</span><br><span class="line">      b:2,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>将立即执行函数赋值给一个变量,并且函数内返回特定值(相当于将这个返回值赋给了一个变量)</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var a=!function()&#123;</span><br><span class="line">    ...</span><br><span class="line">    return&#123;</span><br><span class="line">        b:2,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到1和2两种方式都能够将立即执行函数的内部信息传递给外界，而且乍一看上去，好像方式1更好一点，貌似少用了一个变量啊，其实不然，它最终还是经过了为window对象添加属性的，等同于增加了全局变量，并且还有一个缺点，试想，如果这个函数代码超长，我还需要在函数内去<br>搜索到底哪些地方对window赋值了，才能知道这个立即函数执行后添加了哪些全局变量，所以显然方式2就逻辑清晰多了，只要我们约定俗称了，只需看整个函数所赋值的变量，一切就都明了啦，当然，用方式2的方法，最终要的一点可能是：显得高大上，哈哈</p>
<p>&emsp;&emsp;说到这里，还没说到闭包呢，闭包就是能够访问到外部函数内的变量的函数(函数+能访问到外部函数中的变量，缺一不可~),闭包的常用场景之一是：利用闭包和立即执行函数结合，使得内部信息得以隐藏，只返回必要的方法作为外部接口，实现模块化，现在结合上述提到的立即执行函数的一系列心路历程，感觉清晰了好多！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/DOM事件全整理之从DOM事件级别,DOM事件流到事件委托/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/DOM事件全整理之从DOM事件级别,DOM事件流到事件委托/" itemprop="url">DOM事件全整理之从DOM事件级别,DOM事件流到事件委托</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T16:05:55+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;JS编程中常常接触到DOM事件，虽然只是事件而已，但是处于历史原因，它是足够复杂的，也足够强大的，由于自己之前总是对DOM事件的一些概念模糊不清，所以这里来做一下总结啦</p>
<h2 id="DOM级别与DOM事件"><a href="#DOM级别与DOM事件" class="headerlink" title="DOM级别与DOM事件"></a>DOM级别与DOM事件</h2><p>&emsp;&emsp;我们常听到DOM0级事件，DOM1级事件，DOM2级事件处理，其实这里的DOM0，DOM1，DOM2和DOM级别是密切相关的。</p>
<p>&emsp;&emsp;最开始的时候，IE4和Netscape等浏览器各自实现自己的一套DOM api，没有一个统一的标准，对于开发者和用户来说是一件头疼的事，于是，1998年，W3C综合了各家的现有API,制定了DOM1级(DOM Level 1)标准。DOM1级比较简洁，由两个模块组成：DOM核心（DOM Core）和DOM HTML，其中各个事件相关的信息作为方法包含在在DOM元素中进行说明的，详细可以了解W3C的相关<a href="https://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/level-one-html.html" target="_blank" rel="noopener">章节</a>.</p>
<p>&emsp;&emsp;DOM2级的目标要宽泛很多，引入了多个新模块，其中包括DOM Events，即在DOM2的时候，单独把事件作为一个模块，并针对DOM1级事件部分作了很大的升级，不再只是简单的告诉我们有哪些事件可以用，而是使事件的标准更加详细，如新增了事件流，事件捕获，事件冒泡，事件取消等机制和规范。</p>
<p>&emsp;&emsp;DOM Level 3并没有对事件做任何修订(可能是因为认为DOM Events已经足够成熟了吧),所以我们知道现在用的还是DOM Level 2的事件标准。</p>
<p>&emsp;&emsp;到这里可以做一下总结，DOM API 是有DOM1级，DOM2级，DOM3级三个标准的，与之对应的每一个标准中DOM事件相关的部分我们叫做DOM1级事件处理，DOM2级事件处理(刚才也说了，DOM3级事件处理不存在)，那么标准是从DOM Level 1开始的，我们说的DOM0又是什么呢？可以说这只是公认的一种说法，即在又事实标准之前的事件处理，我们叫做DOM0级事件处理。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>&emsp;&emsp;因为DOM1只是对之前各大厂商的DOM api做了以下整理而实施的标准，所以通常我们认为DOM1的事件处理和DOM0的事件处理是一样的。</p>
<h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>&emsp;&emsp;事件处理程序就是响应某个事件的函数，DOM中的事件处理程序有多种方式，大概可以分为以下五种类型。</p>
<ol>
<li>HTML事件处理程序 </li>
<li>DOM0级事件处理程序</li>
<li>DOM2级事件处理程序</li>
</ol>
<h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(hello world!)&quot;&gt;&lt;/hello&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;像上述代码这样，直接将事件函数写到HTML中元素的属性上，就是HTML事件处理程序，这里双引号中的部分是事件触发后<strong>要执行的代码，它实际上是由JS引擎由<code>eval()</code>调用的</strong>，所以它是全局作用域。</p>
<p>&emsp;&emsp;这样的事件处理有一个明显的缺点，即当JS代码太复杂时，将大段JS代码卸载HTML中显然不合适，于是有了下面这种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;doSomething()&quot;&gt;&lt;/hello&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样虽然解决了嵌套代码过长的问题，但又引来了另一个问题，即时差问题—,如果用户在界面刚出现就进行点击，而JS还没有加载好的话，就会报错。</p>
<p>&emsp;&emsp;此外，很重要的一点是，这种写法，一个函数的改变，可能同时需要js和html的改变，严重违背了轻耦合的原则，综上，我们有了DOM0级事件处理。</p>
<h3 id="DOM0级事件处理"><a href="#DOM0级事件处理" class="headerlink" title="DOM0级事件处理"></a>DOM0级事件处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var btn=document.getElementById(&quot;#btn&quot;);</span><br><span class="line">btn.onclick=function()&#123;</span><br><span class="line">    alert(hello world!)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，这种方式中可以把事件处理相关部门都放到js中，并且这里的事件处理程序是作为btn对象的方法的，是局部作用域。</p>
<p>&emsp;&emsp;但是现在，我依然面临着问题，如果有对这个元素的单击事件添加两个处理函数，这个就无法帮我实现了，而且即使不需要添加多个处理函数，我也不太敢轻易的添加事件，除非我非常确定，别人写代码时不会涉及到这部分(因为一不小心可能会覆盖他人之前对这个元素的该事件添加的处理函数)。</p>
<h3 id="DOM2级事件处理程序-不支持IE"><a href="#DOM2级事件处理程序-不支持IE" class="headerlink" title="DOM2级事件处理程序(不支持IE)"></a>DOM2级事件处理程序(不支持IE)</h3><p>&emsp;&emsp;进一步规范后，有了DOM2级事件处理程序，我们可以通过类似如下代码，对一个元素的同一个事件添加多个处理程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var btn=document.getElementById(&quot;#btn&quot;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(hello world!)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">btn.addEventListener(&quot;click&quot;,function()&#123;</span><br><span class="line">    alert(hello world2!)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;通过DOM2级的<code>addEventListener</code>方法我们可以实现绑定多个事件处理程序，但要注意的是同样的事件和事件流机制下相同的方法只会触发一次，即相同的方法会发生覆盖。<br>等等，这里的事件流又是什么呢？</p>
<h2 id="事件流机制"><a href="#事件流机制" class="headerlink" title="事件流机制"></a>事件流机制</h2><p><img src="http://p4a8bakov.bkt.clouddn.com/event1.png"><br>&emsp;&emsp;我们已经知道，一个元素绑定了特定事件之后，在事件发生的同时，函数就会被调用，但请看上图这种请看，爷爷，父亲和儿子这三个div元素都同时绑定了各自单击事件<code>funcgrand(),funcparent(),funcchild()</code>，那么当我在儿子上单击时，哪个函数会被触发呢？</p>
<p>&emsp;&emsp;首先来分析一下，如果说直观感受是在儿子元素上发生的单击事件，所以应该触发<code>funcchild()</code>,但细细想来这样是不妥的，因为儿子元素本身就是父亲元素甚至爷爷元素的一部分，所以说是不是相当于也在父亲和爷爷元素上发生了单击事件呢？答案是是的，这种情况下三个元素绑定的对应事件的函数都会被浏览器触发，那么问题又来啦，既然三个函数都会被触发，那么它们应该以什么顺序被触发呢，是自上到下呢，还是自下到上呢？</p>
<p>&emsp;&emsp;这个问题也就是我们常说的事件流了，即元素从页面中接收事件的顺序，也即事件在页面中的传播顺序。</p>
<p>&emsp;&emsp;W3C对这个问题给了我们一个答案，就是都可以，既可以自上而下依次触发，又可以自下而上触发，具体顺序由我们自己而定(之所以支持这两种方式，是为了与之前浏览器的实现兼容，因为早期IE事件传播方向为从上至下，而Netscape 则从下至上)。</p>
<h3 id="事件捕获和事件冒泡"><a href="#事件捕获和事件冒泡" class="headerlink" title="事件捕获和事件冒泡"></a>事件捕获和事件冒泡</h3><p>&emsp;&emsp;实际上，之前我们提到的<code>addEventListener</code>还有第三个参数，可以为<code>true</code>或<code>false</code>.当第三个参数为<code>true</code>时，绑定的是捕获阶段的事件，在捕获阶段，事件是由上到下依次触发的，反之当第三个参数为<code>false</code>时，绑定的是冒泡阶段的事件，在冒泡阶段，事件是由下到上触发的。</p>
<p>&emsp;&emsp;W3C规定，当事件发生时，最先通知window,然后是document,由上到下依次进入知道最底层的被触发的那个元素(也就是目标元素，通常的<code>event.target</code>的值)为止，这个过程就是捕获。<br>&emsp;&emsp;之后，事件会从目标元素开始，冒泡，由下至上逐层传递至window,这个过程就是冒泡。</p>
<p>&emsp;&emsp;所以,捕获是会比冒泡先执行的</p>
<h3 id="Tips-1"><a href="#Tips-1" class="headerlink" title="Tips"></a>Tips</h3><p>&emsp;&emsp;正如事件捕获和事件冒泡提到的，事件程序可能会在两个阶段中被执行，即捕获中和冒泡中，当一个事件添加了两个处理函数，一个指定了参数<code>true</code>,一个指定的参数<code>false</code>,则它们都会被执行，且参数为<code>true</code>的那个先执行，因为是捕获阶段先发生.</p>
<p>&emsp;&emsp;但是有一个例外，即如果事件函数被添加在了目标元素本身上，如之前的例题中的儿子元素上被绑定了两个单击事件函数，一个第三个参数是<code>true</code>,一个第三个参数是<code>false</code>，则它们的实际执行顺序是不受第三个参数控制的，而只是单纯的和添加事件的顺序有关(先<code>addEventListener</code>的先执行),这个可能是和处于目标阶段有关(目标阶段和捕获阶段和冒泡阶并称为三大阶段，所以说目标阶段中要把捕获和冒泡的思想排除？真正的顺序是捕获—&gt;目标阶段-&gt;冒泡吧?)？</p>
<h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><p>&emsp;&emsp;对于IE来说，在IE9之前，必须使用<code>attachEvent</code>而不是标准方法<code>addEventListener</code>,IE事件处理程序中有类似于DOM2级事件处理程序的2个方法<code>attachEvent</code>和<code>detachEvent</code></p>
<p>&emsp;&emsp;它们都接收两个参数:</p>
<ol>
<li><p>事件处理程序名称,如 <code>onclick</code>,<code>onmounseover</code>,注意,这里是事件处理程序名称，而不是事件名称，要有前缀<code>on</code> </p>
</li>
<li><p>事件处理程序函数</p>
</li>
<li><p>不像DOM2级事件处理程序一样，它们不接收第三个参数，因为IE8及更早版本只支持冒泡事件流(没有捕获阶段)</p>
</li>
</ol>
<h3 id="Tips-2"><a href="#Tips-2" class="headerlink" title="Tips"></a>Tips</h3><p>&emsp;&emsp;在IE8中，事件执行的顺序不是添加的顺序而是添加顺序的相反顺序，而在IE6,7中 事件执行的顺序是随机的，和添加顺序无关。</p>
<p>&emsp;&emsp; 使用attachEvent方法还有个缺点是，this的值会变成window对象的引用而不是触发事件的元素。 </p>
<h2 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h2><p>&emsp;&emsp;就像上述提到的，老的IE浏览器的事件处理程序不同于标准的DOM2事件处理，所以为了兼容各浏览器的事件处理,我们可以用一个封装的工具函数来实现通用的添加，移除事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var EventUtil=&#123;</span><br><span class="line">    addEventHandler: function(type,element,handler)&#123;</span><br><span class="line">        if(element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(&quot;on&quot;+type,element);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    removeEventHandler: function(type,element,handler)&#123;</span><br><span class="line">        if(element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type,handler,false);</span><br><span class="line">        &#125;else if(element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(&quot;on&quot;+type,element);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            element[&quot;on&quot;+type]=null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>&emsp;&emsp;事件对象是用来记录一些事件发生时的相关信息的对象，但事件对象只有事件发生时才会产生，并且只能在事件处理函数内部访问，在所有事件处理函数结束后，事件对象会被销毁。</p>
<p>&emsp;&emsp;标准的Event对象属性主要有以下几个：</p>
<blockquote>
<ol>
<li>bubbles 布尔值,表示事件是否是冒泡类型</li>
<li>cancelable 布尔值，表示事件是否可以取消默认动作</li>
<li>currentTarget 当前目标元素，即添加当前事件处理程序的元素</li>
<li>target 实际目标元素，即实际触发事件的元素</li>
<li>type 返回当前事件的名称</li>
<li>eventPhase 事件传播的当前阶段,1表示捕获阶段</li>
</ol>
</blockquote>
<p>&emsp;&emsp;标准的Event对象的方法主要有以下几个：</p>
<blockquote>
<ol>
<li>preventDefault() 通知浏览器不要执行该事件的默认动作，常用于阻止链接的跳转，表单的提交，等标签的默认行为</li>
<li>stopPropagation() 冒泡阶段下,阻止事件的继续向上冒泡</li>
</ol>
</blockquote>
<h3 id="事件对象的兼容性"><a href="#事件对象的兼容性" class="headerlink" title="事件对象的兼容性"></a>事件对象的兼容性</h3><p>&emsp;&emsp;和事件处理程序一样，事件对象的属性和方法也存在兼容性问题。</p>
<ol>
<li>事件对象的获取<br>&emsp;&emsp;在IE8及以前的版本中，通过设置属性注册事件处理程序时，调用的时候并未传递事件对象，需要通过全局对象<code>window.event</code>来获取,解决方式如下:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function getEvent(event)&#123;</span><br><span class="line">    event = event || window.event</span><br><span class="line">&#125;</span><br><span class="line">function hander(event)&#123;</span><br><span class="line">    event = getEvent(event)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>阻止默认事件行为</li>
</ol>
<p>&emsp;&emsp;IE浏览器的<code>event</code>事件没有<code>preventDefault()</code>这个方法，但是可以通过设置<code>event</code>的<code>returnValue</code>值为<code>false</code>来达到同样的效果，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">window.event.returnValue=false;</span><br></pre></td></tr></table></figure>
<ol>
<li>阻止冒泡 </li>
</ol>
<p>&emsp;&emsp;IE浏览器的<code>event</code>对象也没有<code>stopPropagation()</code>方法，但可以设置<code>cancelBubble</code>属性为<code>true</code>，阻止事件的继续传播，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">window.event.cancelBubble=true;</span><br></pre></td></tr></table></figure>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>&emsp;&emsp;事件委托就是利用事件冒泡，只需指定一个事件处理程序，就可以管理某一类型的所有事件，通过事件委托，可以做到通过在祖先元素添加一个事件处理程序，就可以控制其子孙元素的某些行为。</p>
<ol>
<li>首先来看利用事件委托来管理某一类型的所有事件的例子。</li>
</ol>
<p>&emsp;&emsp;需求是未ul下的所有li添加click事件对应的行为处理，在没有用事件委托之前，代码是着这样的: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="line">&lt;li&gt;列表项3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var list=document.getElementsByTagName(&quot;li&quot;);</span><br><span class="line">for(i=0;i&lt;list.length;i++)&#123;</span><br><span class="line">    list[i].onclick=function()&#123;</span><br><span class="line">        alert(&quot;我是&quot;+e.target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;目前确实达到了，能够所有li都能对click事件有所响应了，但如果再添加一个添加列表项的按钮呢？当动态的添加列表项时，列表项元素被添加了，可是新添加的节点是没有绑定事件的(除非在添加元素时再加上绑定事件的逻辑)，到这里，我们发现了问题所在:</p>
<blockquote>
<ol>
<li>在所有元素上一一添加事件绑定会导致频繁的操作DOM获取元素,同时多个元素各自监听自己的事件，都会增加浏览器的消耗 </li>
<li>在页面中动态添加元素时，还需要重新走一遍添加监听事件的逻辑才能使新元素能够响应事件 </li>
</ol>
</blockquote>
<p>&emsp;&emsp;庆幸的是，针对这个问题，我们有更好的解决方案，即利用冒泡的原理实现的事件委托。 </p>
<p>&emsp;&emsp;我们只监听最外层元素，然后在事件处理函数中根据事件源，即<code>target</code>属性，进行不同的事件处理，这样，我们只需要针对一个元素添加事件处理程序，极大的降低了DOM访问，并且不需要单独为动态添加的元素添加监听事件了，因为元素的事件会冒泡到最外层，被最外层的事件处理程序截获,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var ul=document.getElementById(&apos;ulList&apos;);</span><br><span class="line">ul.onclick=function(e)&#123;</span><br><span class="line">    var e= e || window.event;</span><br><span class="line">    var target = e.target || e.srcElement;</span><br><span class="line">    if(target.nodeName.toLowerCase() === &quot;li&quot;)&#123;</span><br><span class="line">        alert(&quot;我是&quot;+e.target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;从这个例子可以看出，当用事件委托的时候，完全不需要遍历元素的子节点，只需要给父级元素添加事件监听就好了，之后新添加的子节点也能够同样的对触发事件作出适当的响应 </p>
<ol>
<li>还有一个常见的利用事件委托的例子，就是点开浮层，关闭浮层，我们常常利用事件委托来监听元素外空间区域的点击，来关闭浮层。</li>
</ol>
<h3 id="Tips-3"><a href="#Tips-3" class="headerlink" title="Tips"></a>Tips</h3><blockquote>
<ol>
<li>不是所有事件都是可以委托的。适合用事件委托的事件有:<code>click mousedown mouseup keydown keyup keypresss</code></li>
</ol>
</blockquote>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol>
<li>选择对的事件处理方式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function sayhi()&#123;</span><br><span class="line">    console.log(&quot;hi&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;button id=X onclick=&quot;sayhi&quot;&gt;A&lt;/butotn&gt;//Wrong</span><br><span class="line">&lt;button id=X onclick=&quot;sayhi()&quot;&gt;B&lt;/butotn&gt;//Right</span><br><span class="line">&lt;button id=X onclick=&quot;sayhi.call()&quot;&gt;C&lt;/butotn&gt;//Right</span><br><span class="line"></span><br><span class="line">X.onclick=print;//Right</span><br><span class="line">Y.onclick=print();//Wrong</span><br><span class="line">Z.onclick=print.call();//Wrong</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/不简单的绝对定位,浮动和display inline-block/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/不简单的绝对定位,浮动和display inline-block/" itemprop="url">不简单的绝对定位,浮动和display inline-block</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T18:18:21+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;绝对定位，浮动和<code>display:ilinline-block</code>都是界面布局中常用的设置方式，一直以为这几个属性很简单，在我眼里，想要绝对定位于一个元素时，才会用绝对定位(顾名思义？？)，想要让多个块级元素水平排列时用浮动或<code>display:inline-block</code>(曾经一度觉得这两种方式有些重复，感觉不到它们的区别。。所以自己常常用浮动，<code>display:inline-block</code>用的很少)，最近在看别人代码的时候，照着实现思路重新学习了一下这几个属性，所以这里对它们各自的特性，和彼此之间的异同点，以及何种情况该搬谁来当救兵做了一下小总结~</p>
<p>&emsp;&emsp;开始呢，还是想敲下重点，就是不管是为一个块级元素设置了<code>display:absolute;</code>,<code>float:..</code>,还是<code>display:inline-block</code>也好，这个块级元素的在文档流中的行为都会发生一个变化—就是，它会自动的具有包裹性了，宽度不再自适应父元素的宽度(不过绝对定位元素根据其它设置是会有例外的，稍后会提到)</p>
<h2 id="浮动定位元素"><a href="#浮动定位元素" class="headerlink" title="浮动定位元素"></a>浮动定位元素</h2><p>&emsp;&emsp;浮动元素可以用以下几个点来说明：</p>
<blockquote>
<p>特点：包裹性，脱离文档流(实际是半脱离)<br>应用场景：文字环绕效果；多个块级元素水平排列于一行<br>应用于：块级元素和行内元素皆可</p>
</blockquote>
<h3 id="多个块级元素水平排列成一排"><a href="#多个块级元素水平排列成一排" class="headerlink" title="多个块级元素水平排列成一排"></a>多个块级元素水平排列成一排</h3><p>&emsp;&emsp;需要让多个块级元素水平排列成一行，这是经常需要做的，如左右双列布局，那么既然要让多个元素在一行上，就不能用行内元素吗？答案是，有些情况确实不能，比如说需要给这个元素指定宽和高时，行内元素是不满足需求的。还有一种常见到浮动的应用的场景是水平列表项~ </p>
<h4 id="核心要点-利用包裹性"><a href="#核心要点-利用包裹性" class="headerlink" title="核心要点-利用包裹性"></a>核心要点-利用包裹性</h4><p>&emsp;&emsp;通过设置为浮动让多个元素可以处于一行，这个应用的核心离不开浮动元素的特性之一—包裹性(试想如果没有包裹性了，那么这个元素水平方向的宽度会向父元素的宽度去延展，自己在水平方向就沾满了，无论如何也放不下别人和自己挤在一排了~)</p>
<h4 id="记得善后-清除浮动-不占据文档流位置在作祟"><a href="#记得善后-清除浮动-不占据文档流位置在作祟" class="headerlink" title="记得善后-清除浮动(不占据文档流位置在作祟)"></a>记得善后-清除浮动(不占据文档流位置在作祟)</h4><p>&emsp;&emsp;虽然应用浮动后，看上去达到目的了，但不要忘了善后，清除浮动，因为如果不清除浮动的话，会严重影响其他元素的布局(因为它本身不占据文档流)，带来的后续麻烦可是大大的~~</p>
<p>&emsp;&emsp;上面也提到，浮动元素实际上是半脱离文档流，又为什么说是半脱离呢？这里不是明明说元素浮动以后不占据空间，这不就是脱离文档流了吗？看看下一个应用就知道啦~</p>
<h3 id="文字环绕效果"><a href="#文字环绕效果" class="headerlink" title="文字环绕效果"></a>文字环绕效果</h3><p>&emsp;&emsp;虽然这里文字环绕效果放到了后面写，但实际上最开始之所以有<code>float</code>就是为了实现文字环绕效果。</p>
<h4 id="环绕直接兄弟文字"><a href="#环绕直接兄弟文字" class="headerlink" title="环绕直接兄弟文字"></a>环绕直接兄弟文字</h4><p>&emsp;&emsp;什么是环绕直接兄弟文字呢？也就是一个浮动元素会环绕它的父元素中的文字，这些文字和它是直接兄弟的关系。 </p>
<p>&emsp;&emsp;以下代码是一个没有添加浮动的图像和文字为直接兄弟元素的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  &lt;style&gt;</span><br><span class="line">    div.outer&#123;</span><br><span class="line">      width:400px;</span><br><span class="line">      border:1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">    div&gt;img&#123;</span><br><span class="line">      width:300px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;img src=&quot;http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19img_161967094653.jpg&quot;&gt;</span><br><span class="line">  我是应该要环绕的文字</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;目前真实的效果是这样的：</p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19word1_20180319064514.png"></div>

<p>&emsp;&emsp;可以看到，此时虽然部门文字和图像是在一行的(由默认的行内元素和行内替换元素的对齐方式确实)，但也并不是包裹的效果，接下来为图像添加浮动效果： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">div&gt;img&#123;</span><br><span class="line">    float:left</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;现在效果是这样的，果然文字能够环绕了：</span><br><span class="line"></span><br><span class="line">&lt;div text-align=&quot;center&quot;&gt;&lt;img src=&quot;http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19word2_20180319065327.png&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 侄子文字内容环绕 </span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;曾经一度以为浮动元素只是对直接兄弟元素文字才有影响，但实际上它对叔侄文字内容也有同样的影响，什么是叔侄文字内容呢？简单说就是浮动元素的兄弟元素(可以是行内元素，也可以是块级元素，总之有显示标签)的文字内容，像下面这样是不加浮动的图像和它的侄子文字的关系： </span><br><span class="line"></span><br><span class="line">``` &lt;style&gt;</span><br><span class="line">    div.outer&#123;</span><br><span class="line">      width:400px;</span><br><span class="line">      border:1px solid red;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    div&gt;img&#123;</span><br><span class="line">      width:300px;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    div.inner&#123;</span><br><span class="line">      border:3px solid green;</span><br><span class="line">      width:350px;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;img src=&quot;http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19img_161967094653.jpg&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;inner&quot;&gt;我是应该要环绕的文字&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;现在文字所在的<code>div</code>只是一个普通的块级元素的表现，效果如下：</p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19word4_20180319070752.png"></div>

<p>&emsp;&emsp;同样地，为图像加上左浮动，效果如下：</p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19word5_20180319073015.png"></div>

<p>&emsp;&emsp;也出现了文字环绕，可以看到即使文字是其它元素(如<code>div</code>,<code>span</code>等元素)的子元素，依然会受它的叔叔浮动元素的影响，并且这里有一个需要注意的点，<code>div</code>元素我们指定了宽度是<code>300px</code>,这里即使它紧邻浮动元素，它的指定宽度依然有效，只是它的宽度中的一大部分内容被浮动元素覆盖了，所以文字被挤到了<code>div</code>内容区的另一边,即文字并不像往常一样从父元素的最左侧开始了，(为浮动元素腾位置)，这里由div的边框就可以看到啦 </p>
<h3 id="半脱离文档流"><a href="#半脱离文档流" class="headerlink" title="半脱离文档流"></a>半脱离文档流</h3><p>&emsp;&emsp;从这上两个小节里里，我们除了体会到元素浮动后，它的直接兄弟文字/侄子兄弟文字能够环绕自己外，也能意会一下半脱离文档流： </p>
<blockquote>
<p>&emsp;&emsp; 一个元素浮动后，看上去好像不占据实际文档流空间，它的计算高度为0，进而导致它的父元素的高度为0，所以后续元素可以忽略它的存在，但是如果这个浮动元素直接兄弟元素/侄子元素是文字的话，这些文字还是会受到它的影响，去环绕这个浮动元素。 </p>
</blockquote>
<h2 id="绝对定位元素"><a href="#绝对定位元素" class="headerlink" title="绝对定位元素"></a>绝对定位元素</h2><p>&emsp;&emsp;绝对定位的元素的位置相对于最近的已定位祖先元素，如果元素没有已定位的祖先元素，那么它的位置相对于最初的包含块,这是绝对定位的定义</p>
<p>&emsp;&emsp;绝对定位元素可以用以下几个点来说明：</p>
<blockquote>
<p>特点：包裹性;完全脱离文档流;相对于其它元素定位;生成块级框(即使原来是行内框) </p>
<p>应用场景：绝对定位于某个元素的某个位置;为了动画效果(通过连续调整方位属性<code>left,right,top,bottom</code>来实现动画效果);为了脱离文档流，不影响其他元素的布局(宽度/高度) </p>
<p>应用于：块级元素和行内元素皆可</p>
</blockquote>
<p>&emsp;&emsp;绝对定位其实以前自己很少用，因为我潜意识里简单的认为它的作用只是单纯的像它的名字一样，就是用来绝对定位于一个元素的(只有绝对定位才能实现的定位效果其实也不多，所以很少用，哈哈)，不过最近才意识到，虽然它的名字是绝对定位，但它有很多魔法，利用它的包裹性，脱离文档流，生成块级框的特性可以实现很多巧妙的效果。</p>
<h3 id="绝对定位元素的包裹性"><a href="#绝对定位元素的包裹性" class="headerlink" title="绝对定位元素的包裹性"></a>绝对定位元素的包裹性</h3><p>&emsp;&emsp;一度以为浮动元素和行内元素才具有包裹性，但其实一个元素绝对定位以后也会产生包裹性，这里做一下强调，关于包裹性，最后一小节再详细总结~ </p>
<h3 id="绝对定位来实现导航栏的子列表效果效果"><a href="#绝对定位来实现导航栏的子列表效果效果" class="headerlink" title="绝对定位来实现导航栏的子列表效果效果"></a>绝对定位来实现导航栏的子列表效果效果</h3><p>&esmp;&esmp;&esmp;一个带字列表的水平导航栏，这个效果很常见，也不复杂，所以开始我写了一段代码像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    ul&#123;</span><br><span class="line">      border: 1px solid black;</span><br><span class="line">    &#125;</span><br><span class="line">    li&#123;</span><br><span class="line">      list-style:none;</span><br><span class="line">    &#125;</span><br><span class="line">    .clearfix::after&#123;</span><br><span class="line">      content:&apos;&apos;;</span><br><span class="line">      display:block;</span><br><span class="line">      clear:both;</span><br><span class="line">    &#125;</span><br><span class="line">    div&gt;ul&gt;li&#123;</span><br><span class="line">      </span><br><span class="line">      border:1px solid green;</span><br><span class="line">      margin-left:20px;</span><br><span class="line">      float:left;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;ul class=&quot;clearfix&quot;&gt;</span><br><span class="line">      &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;产品</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;产品1&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;产品2&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;产品3&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">      &lt;li&gt;帮助&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;问题&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;实际效果如下图：</p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19nav1_20180320072437.png"></div>

<p>&emsp;&emsp;开始看上去好像没毛病，仔细看看这里产品和帮助之间的空隙明显比其它项之间的宽度要大(假想把边框去掉，因为边框是我自己方便调试加的~去掉会更明显看出这个bug)，那么有什么解决办法吗？</p>
<h4 id="解决有了字列表项后导航项宽度变宽的问题"><a href="#解决有了字列表项后导航项宽度变宽的问题" class="headerlink" title="解决有了字列表项后导航项宽度变宽的问题"></a>解决有了字列表项后导航项宽度变宽的问题</h4><p>&emsp;&emsp;仔细观察这个问题的原因，其实就是因为添加了字列表项后，子列表比较宽，而字列表也是导航栏中<code>nav&gt;ul&gt;li</code>导航项元素的一部分，所以导航项元素的宽度当然会受它的子列表项的宽度影响？那么有没有什么办法不受它的子列表项宽度影响呢？—-也可以的，让这个子列表项脱离文档流就可以了，所以我们为子列表项添加以下CSS设置： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div&gt;ul&gt;li&#123;</span><br><span class="line">      ....</span><br><span class="line">      position:relative;</span><br><span class="line">&#125;</span><br><span class="line">div&gt;ul&gt;li&gt;ul &#123;</span><br><span class="line">      position:absolute;</span><br><span class="line">      top:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;让子列表项<code>ul</code>相对于对应的导航项绝对定位，现在如下图所示：</p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19nav2_20180320074424.png"></div>

<p>&emsp;&emsp;咦？现在各导航项之间的宽度一致了，不过又出了新的bug,子列表项太丑了，一个列表项还得换行？这是因为设置了绝对定位的元素，它的宽度虽然有包裹性，可以包裹自身的内容，但它的宽度还会有限制性，即不能大于它所相对的元素的宽度，所以在这里由于它所定位的那个元素(导航项)的宽度太小了，它自己的宽度也会尽可能收缩，这才有了这个bug,不过这个问题也好解决，再加一行CSS就可以： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div&gt;ul&gt;li&gt;ul &#123;</span><br><span class="line">      white-space:nowrap;//文字方面的属性，它的子元素会自动继承</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;再来看看下面最终的效果，大功告成啦：</p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19nav3_20180320075313.png"></div> 

<h4 id="核心要点-利用脱离文档流特性和包裹性"><a href="#核心要点-利用脱离文档流特性和包裹性" class="headerlink" title="核心要点-利用脱离文档流特性和包裹性"></a>核心要点-利用脱离文档流特性和包裹性</h4><p>&emsp;&emsp;在这个应用中，核心并不是因为要定位子列表项才用了绝对定位方式(因为其它方式也可以达到想要的位置)，而是因为绝对定位元素的脱离文档流的特性， 才使得子元素可以不影响其它元素(导航项)的布局(包括宽、高、位置等等)，<br>同时绝对定位元素本身具有的包裹性，让子列表项可以自适应宽度，而不至于一味扩张(当然这里它的宽度受到它所相对于定位的元素的宽度的限制，不会大于这个宽度，所以要用<code>white-space:nowrap</code>) </p>
<h2 id="inline-block元素"><a href="#inline-block元素" class="headerlink" title="inline-block元素"></a><code>inline-block</code>元素</h2><p>&emsp;&emsp;设置为行内块的元素可以用以下几个点来说明：</p>
<blockquote>
<p>特点：包裹性，可以设置宽高<br>应用场景：多个块级元素水平排列于一行；用于自适应宽度<br>应用于：块级元素和行内元素皆可</p>
</blockquote>
<h3 id="多个块级元素水平排列成一排-1"><a href="#多个块级元素水平排列成一排-1" class="headerlink" title="多个块级元素水平排列成一排"></a>多个块级元素水平排列成一排</h3><p>&emsp;&emsp;多个块级元素水平排列成一排常常也可以用<code>display:inline-block</code>来实现 </p>
<h4 id="记得善后-解决多个display-inline-block元素之间的空隙"><a href="#记得善后-解决多个display-inline-block元素之间的空隙" class="headerlink" title="记得善后-解决多个display:inline-block元素之间的空隙"></a>记得善后-解决多个<code>display:inline-block</code>元素之间的空隙</h4><p>&emsp;&emsp;多个连续的<code>inline-bolock</code>元素在<code>html</code>中如果有换行符或空格，则浏览器中会表现出多余的空隙,这个问题可以通过设置<code>font-size:0</code>或者<code>letter-spacing</code>为负值来实现，详细了解可以看张鑫旭的文章—<a href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="noopener">去除inline-block元素间间距的N种方法</a> </p>
<h3 id="用于元素的宽度自适应"><a href="#用于元素的宽度自适应" class="headerlink" title="用于元素的宽度自适应"></a>用于元素的宽度自适应</h3><p>&emsp;&emsp;首先来看下面这样一个很常见的导航效果，试着把它做出来。 </p>
<div text-align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/19nav3_20180320075313.png"></div>

<h4 id="水平居中导航栏"><a href="#水平居中导航栏" class="headerlink" title="水平居中导航栏"></a>水平居中导航栏</h4><p>&emsp;&emsp;排除导航栏下方的水平提示条，先来做导航中的水平列表，初步设计一下，水平列表用<code>ul</code>元素下的多个浮动的<code>li</code>元素实现即可，考虑到图中的水平居中的效果，并且<code>ul</code>元素的宽度是不固定的(因为<code>li</code>元素的宽度也会随文字内容而增加)，所以这里就要在<code>ul</code>宽度自适应(总是自动刚好包裹内容)的同时水平居中，仔细想一下，要做到这些，好像只需把<code>ul</code>元素的<code>display</code>属性设置为<code>inline-block</code>即可，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;  </span><br><span class="line">    nav&#123;</span><br><span class="line">      text-align:center;</span><br><span class="line">    &#125;</span><br><span class="line">    ul&#123;</span><br><span class="line">     </span><br><span class="line">      display:inline-block;</span><br><span class="line">    &#125;</span><br><span class="line">    li&#123;</span><br><span class="line">      list-style:none;</span><br><span class="line">    &#125;</span><br><span class="line">    .clearfix::after&#123;</span><br><span class="line">      content:&apos;&apos;;</span><br><span class="line">      display:block;</span><br><span class="line">      clear:both;</span><br><span class="line">    &#125;</span><br><span class="line">    nav&gt;ul&gt;li&#123;</span><br><span class="line">      </span><br><span class="line">   </span><br><span class="line">      margin-left:20px;</span><br><span class="line">      float:left;</span><br><span class="line">      position:relative;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    nav&gt;ul&gt;li:nth-child(1)&#123;</span><br><span class="line">      margin-left:0;</span><br><span class="line">    &#125;</span><br><span class="line">    nav&gt;ul&#123;</span><br><span class="line">      margin:0;</span><br><span class="line">      padding:0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;nav&gt;</span><br><span class="line">    &lt;ul class=&quot;clearfix&quot;&gt;</span><br><span class="line">      &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;帮助&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;问题&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/nav&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，为了实现<code>nav</code>水平居中的效果，主要利用了以下两个特性：</p>
<blockquote>
<p>&emsp;&emsp;将<code>ul</code>设置为<code>inline-block</code>元素，通过具有包裹性使其自适应子元素宽度<br>&emsp;&emsp;为<code>ul</code>的父元素<code>nav</code>设置<code>text-align:center</code>属性，使<code>ul</code>元素(行内块)水平居中 </p>
</blockquote>
<h4 id="添加下方的bar"><a href="#添加下方的bar" class="headerlink" title="添加下方的bar"></a>添加下方的<code>bar</code></h4><p>&emsp;&emsp;正如图中所示，还需要在导航条下方添加一个等宽的水平条，根据语义化原则，我们可以把<code>bar</code>添加到<code>nav</code>的后一个子元素中，像下面这样： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul class=&quot;clearfix&quot;&gt;</span><br><span class="line">      &lt;li&gt;首页&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;产品&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;帮助&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;问题&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;但是问题来了，像图中一样，<code>bar</code>的宽度也是自适应的，明显它和<code>ul</code>列表的宽度是保持一致的,这如何做到呢？很明显照目前的布局是无法做到的，因为<code>ul</code>列表的宽度只是自适应，没有具体值，不能给它的兄弟元素<code>bar</code>传递任何具体信息，而<code>bar</code>的父元素是块级元素<code>nav</code>,宽度自动扩张类型的，分析到这里，看似走到死胡同，但谜底好像也来了，只要让<code>nav</code>不再是块级元素，也是<code>inline-block</code>元素不就好了嘛，这样<code>nav</code>就会具有包裹性自适应子元素<code>ul</code>的宽度，而另一个子元素<code>bar</code>的宽度也会随之自适应了，同时<code>nav</code>设置为<code>inline-block</code>后，之前设置的居中效果无效了，只需再为<code>nav</code>的父元素设置<code>text-align:center</code>属性即可，变更代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.wrapper&#123;</span><br><span class="line">     text-align:center;</span><br><span class="line">   &#125;</span><br><span class="line">   .bar&#123;</span><br><span class="line">     height:5px;</span><br><span class="line">     background:#fff;</span><br><span class="line">     border-radius:6px;</span><br><span class="line">   &#125;</span><br><span class="line">   .bar::after&#123;</span><br><span class="line">     display:block;</span><br><span class="line">     content:&apos;&apos;;</span><br><span class="line">     height:100%;</span><br><span class="line">     background:red;</span><br><span class="line">     width:40px;</span><br><span class="line">     border-radius:6px;</span><br><span class="line">   &#125;</span><br><span class="line">   nav&#123;</span><br><span class="line">     display:inline-block;</span><br><span class="line">     .......</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>&emsp;&emsp;可以看到，在这个应用中，不管是做水平导航栏还是在完成下方的<code>bar</code>时，我们并没有想要利用<code>inline-block</code>去水平排列多个块级元素(在水平导航栏的实现中，利用了浮动)，但是每一步中我们的核心都利用了<code>display:inline-block</code>属性,目的就是使块级元素的宽度自适应(看来<code>inline-block</code>能使块级元素宽度自适应这个功能还是很有用的，常常被我忽略~~) </p>
</blockquote>
<h2 id="不简单的包裹性"><a href="#不简单的包裹性" class="headerlink" title="不简单的包裹性"></a>不简单的包裹性</h2><p>&emsp;&emsp;原来包裹性不只是简单的能包裹住它里面的内容，它还会受到一些限制，也可能有一些附加功能，这里也做一些总结 </p>
<h3 id="包裹性元素的类型"><a href="#包裹性元素的类型" class="headerlink" title="包裹性元素的类型"></a>包裹性元素的类型</h3><p>&emsp;&emsp;首先行内块元素和行内元素是自身就具有包裹性的，这里所要说的是将块级元素转换为具有包裹性元素的情况，主要有以下三种:</p>
<ul>
<li><p>设置为浮动元素 </p>
</li>
<li><p>通过<code>display:inline-block</code>设置为行内块元素 </p>
</li>
<li><p>设置为绝对定位元素 </p>
</li>
</ul>
<p>Tips:这里仅仅是说这几种设置方式应用于块级元素会使得块级元素具有包裹性，不代表他们不能应用于行内元素，只是那时候可能会有其它作用:) </p>
<h3 id="包裹性元素宽度的限制"><a href="#包裹性元素宽度的限制" class="headerlink" title="包裹性元素宽度的限制"></a>包裹性元素宽度的限制</h3><p>&emsp;&emsp;包裹性元素的宽度并不是单纯的由自身的内容决定，它们还会受到一些其它方面的限制，它们各自都有自己的宽度最大值：</p>
<blockquote>
<p>&emsp;&emsp;都可以显示指定宽度来限制包裹性元素的最大宽度值 </p>
<p>&emsp;&emsp;<code>inline-block</code>的元素的宽度最大值受到其父元素宽度的限制 </p>
<p>&emsp;&emsp;浮动元素虽然(半)脱离文档流，但它的宽度最大值也要受到其父元素宽度的限制 </p>
<p>&emsp;&emsp; 绝对定位元素时完全脱离文档流的，但它和浮动元素类似，也会受到普通文档流中的元素的宽度的限制，只是这个元素不一定是其父元素，而是被它绝对定位于的那个元素(它的第一个定位过的祖先元素或根元素) </p>
</blockquote>
<h3 id="包裹性元素的包裹性"><a href="#包裹性元素的包裹性" class="headerlink" title="包裹性元素的包裹性"></a>包裹性元素的包裹性</h3><p>&emsp;&emsp;在满足包裹性元素的宽度限制的情况下，它会尽可能的延展自己的宽度能够包裹住自身内容，当刚好包裹的时候，停止延展；反之，如果在延展的过程中，达到了它的极限值，即上一节计算出的应有的最大值，这时候它的内容(如文字，指定宽度的块级子元素除外，因为想换行也换不了:)会自动换行。</p>
<h3 id="包裹性元素的包裹性会影响子级块元素的宽度"><a href="#包裹性元素的包裹性会影响子级块元素的宽度" class="headerlink" title="包裹性元素的包裹性会影响子级块元素的宽度"></a>包裹性元素的包裹性会影响子级块元素的宽度</h3><p>&emsp;&emsp;无论是<code>inline-block</code>,浮动元素，还是绝对定位元素所形成的包裹性元素，都不只是仅仅使得自身具有包裹性，而是会进一步影响其子孙元素，使他们的宽度被限制。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/用animation-delay实现一个loading效果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/用animation-delay实现一个loading效果/" itemprop="url">用animation-delay实现一个loading效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T08:53:08+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>要实现的loading效果是这样的<a href="https://jsbin.com/nulasok/edit?html,output" target="_blank" rel="noopener">点击这里查看</a>,这里对如何制作这样一个loading效果做一下总结</p>
<h2 id="效果分析"><a href="#效果分析" class="headerlink" title="效果分析"></a>效果分析</h2><ol>
<li>打开Console的Animations选项卡，以10%的速率放慢动画观察效果</li>
<li>发现动画是由内外两个圆圈组成，而且内外圆圈效果几乎一样，只是有不同的动画延迟<br>3.圆圈由小到大，逐渐淡出<h2 id="效果实现"><a href="#效果实现" class="headerlink" title="效果实现"></a>效果实现</h2></li>
</ol>
<h3 id="外层wrapper"><a href="#外层wrapper" class="headerlink" title="外层wrapper"></a>外层wrapper</h3><p>首先画一个wrapper,让动画的两个圆圈在这个wrapper中绝对居中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> #wrapper&#123;</span><br><span class="line">      width:100px;</span><br><span class="line">      height:100px;</span><br><span class="line">      border:1px solid red;</span><br><span class="line">      position:relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id=&quot;wrapper&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="第一个圆圈"><a href="#第一个圆圈" class="headerlink" title="第一个圆圈"></a>第一个圆圈</h3><p>画出第一个圆圈，让其居中于外层wrapper,且自带动画效果，由小到大，逐渐淡出，动画效果呈线性，且无限循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.circle&#123;</span><br><span class="line">      width:10px;</span><br><span class="line">      height:10px;</span><br><span class="line">      background:black;</span><br><span class="line">      border-radius:50%;</span><br><span class="line"></span><br><span class="line">     //绝对定位居中于父元素</span><br><span class="line">      position:absolute;</span><br><span class="line">      left:0;</span><br><span class="line">      right:0;</span><br><span class="line">      top:0;</span><br><span class="line">      bottom:0;</span><br><span class="line">      margin:auto;</span><br><span class="line"></span><br><span class="line">      //圆圈的动画效果</span><br><span class="line">      animation: s 1.5s linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//动画定义</span><br><span class="line">@keyframes s&#123;</span><br><span class="line">      0%&#123;width:0px; height:0px; opacity:1;&#125;</span><br><span class="line">      100%&#123;width:100px; height:100px; opacity:0;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div id=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;cirle&quot;&gt;&lt;circle&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="第二个圆圈"><a href="#第二个圆圈" class="headerlink" title="第二个圆圈"></a>第二个圆圈</h3><p>将第二个圆圈设为和第一个一样的效果，只是加上合适时间的动画延迟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#wrapper:nth-child(2)&#123;</span><br><span class="line">      animation-delay:0.75s;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div id=&quot;wrapper&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;cirle&quot;&gt;&lt;circle&gt;</span><br><span class="line">  &lt;div class=&quot;cirle&quot;&gt;&lt;circle&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>目前为止，loading动画已经基本实现，接下来，做一些些优化</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="用伪元素代替div"><a href="#用伪元素代替div" class="headerlink" title="用伪元素代替div"></a>用伪元素代替div</h4><p>效果中，wrapper元素中的两个圆圈只是用来设置了元素样式，没有充当其他元素的容器，所以这里我们用before,after伪元素来替代两个circle类元素，注意：<strong>伪类元素要生效必须设置<code>content</code>属性</strong></p>
<h4 id="用loading类代替wrapper"><a href="#用loading类代替wrapper" class="headerlink" title="用loading类代替wrapper"></a>用loading类代替wrapper</h4><p>用loading代替class,使元素更具有语义化</p>
<p>最终代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;loading animation&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .loading&#123;</span><br><span class="line">      width:100px;</span><br><span class="line">      height:100px;</span><br><span class="line">      position:relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .loading::before,.loading::after&#123;</span><br><span class="line">      content:&apos;&apos;;</span><br><span class="line">      width:10px;</span><br><span class="line">      height:10px;</span><br><span class="line">      position:absolute;</span><br><span class="line">      background:black;</span><br><span class="line">      border-radius:50%;</span><br><span class="line">      left:0;</span><br><span class="line">      right:0;</span><br><span class="line">      top:0;</span><br><span class="line">      bottom:0;</span><br><span class="line">      margin:auto;</span><br><span class="line">      animation: s 1.5s linear infinite;</span><br><span class="line">    &#125;</span><br><span class="line">    .loading::after&#123;</span><br><span class="line">      animation-delay:0.75s;</span><br><span class="line">    &#125;</span><br><span class="line">    @keyframes s&#123;</span><br><span class="line">      0%&#123;width:0px; height:0px; opacity:1;&#125;</span><br><span class="line">      100%&#123;width:100px; height:100px; opacity:0;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;loading&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在只要引入如下代码，就能引入loading元素了,具体效果可以看这里- <a href="https://jsbin.com/nulasok/edit?html,output" target="_blank" rel="noopener">用JSbin打开]loading animation</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/块级元素具有包裹性后其宽度和其后代块级元素宽度的关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/15/块级元素具有包裹性后其宽度和其后代块级元素宽度的关系/" itemprop="url">块级元素具有包裹性后其宽度和其后代块级元素宽度的关系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-15T21:40:48+08:00">
                2018-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>普通块级元素的宽度是受到父元素宽度影响的，满足等式<code>子元素margin-left+子元素border-left+子元素padding-left+子元素width+子元素padding-right+子元素border-right+子元素paddig-right=父元素width</code>,<br>当子元素的边框值，内外边距都等于0时，由公式可以推导出，子元素的宽度即等于父元素的宽度。<br>即普通的块级元素的宽度是具有扩张性的，即以父元素为基础(父元素的宽度是固定的)，会自动填充父元素的内容，但是当块级元素具有包裹性后，它的宽度会由自身内容决定，完全不同以往，那么块级元素如何才会具有包裹性呢？</p>
<h2 id="块级元素如何具有包裹性"><a href="#块级元素如何具有包裹性" class="headerlink" title="块级元素如何具有包裹性"></a>块级元素如何具有包裹性</h2><p>要让块级元素具有包裹，可以划分为三种方式</p>
<ul>
<li>通过为元素属性<code>display</code>设置为<code>inline-block</code>将元素设置为行内块元素</li>
<li>将元素设置为浮动元素</li>
<li>将元素设置为绝对定位(<code>absolute</code>或者<code>fixed</code>)<h2 id="包裹性块级元素的宽度"><a href="#包裹性块级元素的宽度" class="headerlink" title="包裹性块级元素的宽度"></a>包裹性块级元素的宽度</h2>固名思义，包裹性块级元素，既然包裹，那么它的宽度会由它的内容的宽度来决定，道理很简单，但真的是这样简单吗，举例说明就知道了~</li>
</ul>
<h2 id="包裹型元素和其子元素宽度的互相影响"><a href="#包裹型元素和其子元素宽度的互相影响" class="headerlink" title="包裹型元素和其子元素宽度的互相影响"></a>包裹型元素和其子元素宽度的互相影响</h2><p>为了更明显的观察规律，本例中为所有元素都添加了不同颜色的边框。<br>首先来看一个普通div元素的宽度，和这个元素行内块化后的效果对比图：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/14inline1.png"></image></div>


<p>相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.outer&#123;</span><br><span class="line">      border:2px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">    div&#123;</span><br><span class="line">      margin-bottom:5px;</span><br><span class="line">      padding-top:2px;</span><br><span class="line">      padding-bottom:2px;</span><br><span class="line">    &#125;</span><br><span class="line">    .inlineblock&#123;</span><br><span class="line">      display:inline-block;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">.first span&#123;</span><br><span class="line">      border: 1px solid green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;div class=&quot;outer&quot;&gt;我是一个普通块级元素&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot; outer inlineblock first&quot;&gt;&lt;span&gt;我是一个inline-block元素&lt;/span&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>可见，为外层div设置为<code>inline-block</code>后,当其子元素为非块级元素时，元素的宽度由子元素的宽度决定</p>
<h3 id="当包裹型元素的子元素同时有块级元素和非块级元素时"><a href="#当包裹型元素的子元素同时有块级元素和非块级元素时" class="headerlink" title="当包裹型元素的子元素同时有块级元素和非块级元素时"></a>当包裹型元素的子元素同时有块级元素和非块级元素时</h3><p>想到这个问题时，总会一不小心发现一个悖论，包裹型元素本身的宽度由其子元素的宽度决定，那么当它的子元素是一个普通块级元素时，也不例外吗？这样的话，父元素由子元素决定，但因为这个子元素是一个普通块级元素，普通块级元素的宽度不是由父元素决定吗？这样无线循环，到底要怎样呢（懵懵懵），额，既然这样，直接看例子还是，看能不能找得到答案</p>
<p>首先来做第一个实验，相关示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.outer&#123;</span><br><span class="line">      border:2px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">    div&#123;</span><br><span class="line">      margin-bottom:5px;</span><br><span class="line">      padding-top:2px;</span><br><span class="line">      padding-bottom:2px;</span><br><span class="line">    &#125;</span><br><span class="line">    .inlineblock&#123;</span><br><span class="line">      display:inline-block;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">.seconed span&#123;</span><br><span class="line">      border: 1px solid green;</span><br><span class="line">    &#125;</span><br><span class="line">.seconed div&#123;</span><br><span class="line">    border: 1px solid black;</span><br><span class="line">&#125;</span><br><span class="line">  &lt;div class=&quot; outer inlineblock seconed&quot;&gt;</span><br><span class="line">    &lt;span&gt;我是一个inline-block元素&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;我是一个div元素，内容比较长&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>图示效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/14inline2.png"></image></div>

<p>由图中可以看出，外层inline-block元素的边框是紧紧包裹着内层div元素的，而div元素的边框恰好包裹了自身的内容，从这里是不是可以推出？当一个div具有包裹性后，其后代块级元素的宽度也具有了包裹性，由自身的内容决定，同样的，最外层的div由内层的块级元素的宽度决定了？由这个效果看确实是符合的。</p>
<p>然后，下面一次实验中我仅仅是把元素的文字内容换了，结果效果却大不相同，文字内容变换部分如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot; outer inlineblock seconed&quot;&gt;</span><br><span class="line">  &lt;span&gt;我是一个inline-block元素,内容比较长&lt;/span&gt;</span><br><span class="line">  &lt;div&gt;我是一个div元素，内容比较短&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>此时效果如下：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/14inline3.png"></image></div>

<p>乍一看好像没什么不同，外层div的红色边框依然紧紧包裹着内层div的黑色边框，可仔细一看发现了异常，说好的内层div继承包裹性呢？这里明明它的黑色边框没有包裹住自身的文字内容，反倒看上去相似填充了外层div的宽度，这不是和上一例相矛盾吗？话说回来，这次内层div填充了外层div的宽度，那外层div宽度是哪儿来的？不要忘了，它还有另一个span子元素，这时候的外层div的边框不是恰好包裹了span子元素的边框吗？这样好像说的通了，可是外层元素到底是根据div子元素的宽度而定还是根据span子元素的内容而定呢？div子元素的边框到底是包裹自身内容还是应该填充父元素的内容呢？其实也简单，不妨分几步看一下</p>
<p>当一个块级元素具有包裹性时，它本身的宽度和它的子元素的宽度计算法则可以按照以下步骤：<br>1.首先找出该元素的所有非块级子元素，并分别按行计算出一行中的非块级子元素的和宽度和，取宽度和最大的一个，计为maxInineWidth,如上面两个例子中，子元素中只有一行涉及到了非块级元素，且该行只有一个span元素，因此span元素的宽度即是这里所求的maxInlineWidth值(注意：极端情况不含有非块级子元素，maxInlineWidth值为0)</p>
<ol>
<li>然后计算下各个普通文档流块级元素的宽度(脱离文档流的块级元素无需计算在内)，将块级子元素看做是纯包裹性元素，即它的宽度由其自身内容而定，找出最宽的div，将这个宽度值记为maxDivWidth<br>3.比较maxInlineWidth和maxDivWidth的值，取最大的一个，记为maxWidth,则外层的div对的宽度即为maxWidth<br>4.现在外层div的宽度已经确定了，所有子块级元素的宽度该扩充外层div了，即在第二步中计算出的所有宽度小于maxWidth的块级元素，都自动扩充内容区域填满外层div的宽度(而子元素中不属于块级元素的元素无需扩张了，因为行内块元素本身就是实实在在的包裹性元素，不受父元素宽度影响，当然，父元素宽度过小时，也会影响它，即它的宽度不会超过父元素，如文字内容在触碰到父元素的边框时会自动换行)</li>
</ol>
<p>以上的计算方式其实是在外层包裹性元素的宽度不会受其它元素限制，可以随子元素内容扩充的情况下才有效的，即若外层包裹性元素的宽度受限的话，计算出的maxWidth有可能大于外层包裹性元素的受限宽度，此时，该外层包裹性元素的宽度依然取得是它的受限宽度(即因为受限，宽度最大不能超过XXX，或者因为受限，宽度必须为XXX)，受限的情况可能有好几种，比如以下两种情况：</p>
<ul>
<li><p>该包裹性元素的父元素的宽度是一定的，那么该元素的宽度肯定不会超过父元素(<strong>如果包裹性元素是绝对定位元素，则是它的宽度不会超过被绝对定位的元素的宽度,本文中提到包裹性元素和父元素的关系时，如果是绝对定位元素，则父元素均应用被绝对定位的那个元素替换，本文其它地方为了统一说明，均用父元素代替</strong>)的宽度值，此时跳过第2,3，步，直接取受限宽度和maxInlineWidth值的最大值作为外层包裹性元素的宽度即可，其它步骤一样；</p>
</li>
<li><p>显示为该包裹性元素指定了width值得话，那么该包裹性元素的宽度值也确定了，此时可以直接跳过1,2,3，即maxWidth的值直接为它的指定值，子块级元素受限于该外层div元素的同时也会依据它来扩充（即子元素的宽度不会超过该宽度值，但当子块级元素按包裹性计算为比该宽度值小时，又会自动扩充到该宽度值）。</p>
</li>
</ul>
<p>由第3步可以看到，<strong>外层div的宽度是不会受到子元素中的不处于文档流的元素(如绝对定位或浮动)的任何影响的，但子元素中的不处于文档流的块级元素自身的宽度还是和普通块级元素一样，是会受到外层包裹元素宽度的制约的(不会超过这个值)，不同的一点是，它不会自动扩充为何外层包裹性元素同宽(当自身包裹内容原本小于父元素宽度值时，因为脱离文档流了，变为纯包裹性元素(浮动元素和绝对定位元素都是)不再自动扩充。。)</strong>。自己试验验证一下即可，也可以看<a href="https://hitobear.github.io/2018/03/14/%E4%BB%8E%E4%B8%80%E6%AC%A1%E5%88%A9%E7%94%A8%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D%E5%BC%95%E5%8F%91%E7%9A%84bug%E6%84%9F%E6%82%9F%E5%87%BA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%85%E8%A3%B9%E6%80%A7%E5%AE%BD%E5%BA%A6/" target="_blank" rel="noopener">这篇文章</a>的一个例子了解一下。</p>
<p>综上：当外层块级元素具有包裹性后(可能由于浮动，绝对定位，或变为行内块元素)，它和它的子块级元素的宽度是互相影响的，并不是绝对的一个根据另一个而定，只不过表现的结果是，不管哪种情况(父级元素宽度等于子级元素宽度，或子级元素宽度扩充为父级元素宽度)，表现结果均为，父级元素宽度和子级块元素的宽度是一样的(当子级块元素非处于文档流中的元素中时则例外，<strong>此时因为变为纯包裹性元素，和行内块元素一样，有可能小于父级元素宽度</strong>）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/14/从一次利用块级元素绝对定位引发的bug感悟出元素的包裹性宽度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/从一次利用块级元素绝对定位引发的bug感悟出元素的包裹性宽度/" itemprop="url">从一次利用块级元素绝对定位引发的bug感悟出元素的包裹性宽度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T00:13:19+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇总结的起因为我在写导航栏时遇到的一个bug,开始时，导航栏的相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">  &lt;title&gt;JS Bin&lt;/title&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    a&#123;</span><br><span class="line">        text-decoration:none;</span><br><span class="line">        color:white;</span><br><span class="line">    &#125;</span><br><span class="line">    li&#123;</span><br><span class="line">      list-style: none;</span><br><span class="line">    &#125;</span><br><span class="line">   .header nav&#123;</span><br><span class="line">        float:right;</span><br><span class="line">        padding-top:7px;</span><br><span class="line">    &#125;</span><br><span class="line">    nav&gt;ul&gt;li &#123;</span><br><span class="line">        float:left;</span><br><span class="line">        margin:0 17px;</span><br><span class="line">    &#125;</span><br><span class="line">    nav&gt;ul&gt;li&gt;a &#123;</span><br><span class="line">        </span><br><span class="line">        border-top:   3px solid transparent; </span><br><span class="line">        border-bottom: 3px solid transparent;</span><br><span class="line">        padding-top:5px;</span><br><span class="line">        padding-bottom:5px;</span><br><span class="line">        display:block;</span><br><span class="line">        font-weight:bold;</span><br><span class="line">        font-size:12px;</span><br><span class="line">        color:inherit;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"> &lt;div class=&quot;header clearfix&quot; id=&quot;header&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;header-inner&quot;&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;ul class=&quot;clearfix&quot;&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;技能&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;作品&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;博客&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;日历&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系方式&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/nav&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果如下图一：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/13nav0_20180313225537.png"></image></div>

<div align="center">图1</div><br>接下来我要实现的效果是在博客这一列表项下添加3个子列表，所以我对html简单了添加了以下内容：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;</span><br><span class="line">       &lt;a href=&quot;#&quot;&gt;博客&lt;/a&gt;</span><br><span class="line">      &lt;ul&gt;//新增ul元素</span><br><span class="line">             &lt;li&gt;博客1&lt;/li&gt;</span><br><span class="line">             &lt;li&gt;博客2&lt;/li&gt;</span><br><span class="line">              &lt;li&gt;博客2&lt;/li&gt;</span><br><span class="line">       &lt;/ul&gt;</span><br><span class="line"> &lt;/li&gt;</span><br></pre></td></tr></table></figure><br><br>现在，导航栏效果如下图2：<br><br><div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/13nav2_20180313230704.png"></image></div>

<div align="center">图2</div><br>可以看到，添加了ul列表后，基本实现了子级列表项，但可以明显的看到，此时原列表项博客，收到了子列表项宽度的影响，被明显的拉宽了，这样显然不优雅，那么有没有什么办法，使其不受子列表项的影响，自身宽度保持不变呢？这时候想到了，将子列表项绝对定位，使其脱离文档流， 这样它的宽度肯定不会影响到父元素的宽度了，于是为字列表项ul元素添加了相对于父元素li的绝对定位，相关CSS代码如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nav&gt;ul&gt;li &#123;</span><br><span class="line">        position:relative;</span><br><span class="line">    &#125;</span><br><span class="line">    nav&gt;ul&gt;li&gt;ul&#123;</span><br><span class="line">      position:absolute;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br>本以为这下可以完成任务了，结果刷新后，效果却如下图3所示<br><div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/13nav3_20180313231556.png"></image></div><br><div align="center">图2</div><br>是的，正如图中所示，绝对定位解决了列表项宽度受影响的问题，但却引入了新的问题，子列表项的宽度太窄了！！那么这是什么原因呢？实验后发现这个表现有两方面的综合原因。<br><br>## 块级元素绝对定位后，它本身及其所有后代块级元素会有包裹性<br>最开始的块级元素及其子元素的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> .pos&#123;</span><br><span class="line">      </span><br><span class="line">      border:1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">    .first&#123;</span><br><span class="line">      border: 1px solid green;</span><br><span class="line">      margin-bottom:10px;</span><br><span class="line">    &#125;</span><br><span class="line">    .seconed&#123;</span><br><span class="line">      border: 1px solid black;</span><br><span class="line">    &#125;</span><br><span class="line">    .seconed div&#123;</span><br><span class="line">      border: 1px solid #888;</span><br><span class="line">      margin-bottom:5px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;pos&quot;&gt;&lt;div class=&quot;first&quot;&gt;第一个子元素div&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;seconed&quot;&gt;&lt;div&gt;第二个子元素的子元素1 &lt;/div&gt;</span><br><span class="line">    &lt;div&gt;第二个子元素的子元素2 &lt;/div&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><br><br>效果如下图4所示：<br><div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/13nav4_20180313234058.png"></image></div>

<div align="center">图4</div>

<p>然后为了观察绝对定位的影响，为最外层的div元素设置为绝对定位，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.pos&#123;</span><br><span class="line">      position:absolute;</span><br><span class="line">     ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>之后，效果如图5：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/13nav5_20180313234109.png"></image></div>

<div align="center">图5</div>

<p>对比图5发现，添加绝对定位以后，不管是其本身还是直接子元素<code>first</code>类的<code>div</code>,或是其孙元素<code>seconed</code>类的<code>div</code>的子元素，其宽度均收缩为所包含文字需要的宽度，不再主动填充外层容器，展现了其宽度的包裹性。</p>
<h2 id="块级元素绝对定位后，它本身的宽度依然不能超过父元素的宽度"><a href="#块级元素绝对定位后，它本身的宽度依然不能超过父元素的宽度" class="headerlink" title="块级元素绝对定位后，它本身的宽度依然不能超过父元素的宽度"></a>块级元素绝对定位后，它本身的宽度依然不能超过父元素的宽度</h2><p>这个特性其实是通俗特性的扩展，及无论是否脱离文档流，div元素本身的宽度都不能自动超出父元素的宽度，除非显示指定宽度值。<br>在最开始的导航栏一例中，设置了绝对定位后，因为脱了了文档流，而恰好其父元素<code>li</code>又设置过<code>float:left</code>属性，因此<code>li</code>的宽度本身就又包裹性，<strong>(浮动元素的宽度包裹性和绝对定位元素的宽度包裹性异曲同工)</strong>,只会包裹住其子元素a标签的内容，(因为ul绝对定位后脱离了文档流，没有绝对定位时还在文档流中，是可以包裹住的，所以绝对定位前ul列表的宽度是正常的)，所以ul标签的宽度受限于父元素li的宽度，当然很窄了！！</p>
<h2 id="如何解决层层包裹性带来的文字自动换行的bug"><a href="#如何解决层层包裹性带来的文字自动换行的bug" class="headerlink" title="如何解决层层包裹性带来的文字自动换行的bug?"></a>如何解决层层包裹性带来的文字自动换行的bug?</h2><p>经过上面的分析，这里bug的主要原因还是 <code>ul</code>绝对定位以后元素自身脱离文档流，导致浮动的父元素<code>li</code>(本身也有包裹性)未将子元素<code>ul</code>宽度包裹住，只包裹了<code>a</code>标签的宽度，所以，虽然此时ul按理说应该能包裹住子元素的宽度的，但是因为其父元素li宽度过窄，导致ul及其子元素的宽度也受限，其文字内容不得不自动换行了。<br>这里为了解决这个bug，可以换一种思路，只要文字不自动换行是不是就可以了？添加如下样式，即增加<br><code>white-space:nowrap;</code>属性设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nav&gt;ul&gt;li&gt;ul&#123;</span><br><span class="line"> .....</span><br><span class="line">  white-space:nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在效果如图6所示：</p>
<div align="center"><image src="http://p4a8bakov.bkt.clouddn.com/image/css/2018/03/13nav6_20180314000504.png"></image></div>

<div align="center">图6</div>

<p>bug完美解决了~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/13/理解prototype和_proto_/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hitobear">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小笨熊的旅途">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/13/理解prototype和_proto_/" itemprop="url">理解prototype和__proto__</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-13T21:48:31+08:00">
                2018-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>prototype和<strong>proto</strong>时对象属性的访问过程中至关重要的两个属性，这里主要对这两个属性的特点和意义作一些总结。</p>
<h1 id="从对象的属性说起"><a href="#从对象的属性说起" class="headerlink" title="从对象的属性说起"></a>从对象的属性说起</h1><p>首先，<strong>假设不存在prototype和<strong>proto</strong></strong>,我们知道JS的是存在Object类型的，和很多面向对象语言一下，类型是对多个同种类对象的封装，如学生A存在年龄，姓名，性别，父母，学校，班级,toString,valueOf等属性，和起床，跑步，上学，下课四个方法，学生B，C同样存在这些属性和方法，为了统一管理这些学生的属性和行为，我们可以提供一个Student类，Student类中包含了所有的这些属性和方法，这是通过Student类就可以创建多个学生对象，假设创建了学生a,b,c,现在内存中a,b,c对象的构成是下图1所示的样子：</p>
<div align="center"><img src="http://p4a8bakov.bkt.clouddn.com/objectorigin.png"></div><br><div align="center">图1</div>

<h2 id="多个同类对象的问题"><a href="#多个同类对象的问题" class="headerlink" title="多个同类对象的问题"></a>多个同类对象的问题</h2><p>由图1可以看到，在这种未经过任何处理的存储结果下，a,b,c三个学生的属性在内存中确实可以完整的存储和访问，但是稍加思考就能觉得好像哪里不太对，是的，有一些属性实在每个学生里都出现的，比如图中可以看到的<code>run(),study(),gotoschool()</code>以及图中没有画出的<code>toString(),valueOf()</code>方法，这么多同样的属性，实际上是没有任何区别的，那位什么要在每一块内存里都存一遍呢？现在只是三个对象，如果会新建成百上千个这类对象呢，空间浪费岂不大发了？这里为了践行不浪费一粒空间的宗旨，前辈们想到了<strong>共享属性</strong>,如何让这些没有任何区别的属性内在不同对象之间共享，那就好了！于是就有了以下的图2：</p>
<p><div align="center"><img src="http://p4a8bakov.bkt.clouddn.com/objectproto.png"></div></p>
<p><div align="center">图2</div><br>可以看到，在这种结构中，a,b,c三个对象中的属性值相同的几个属性均消失了，代替的是多了一个名为<code>__proto__</code>的属性,图中可以看出，<code>__proto__</code>是一个对象，这个对象所包含的属性正是学生类对象的共享属性，通过把这几个共享的属性放到同一块内存中构成一个对象p，并且通过新增<code>__proto__</code>属性的方式，使得对象可以引用到这个对象p,就实现了<em>通过引用同样的<strong>prop</strong>属性来共享属性对象</em></p>
<h2 id="访问共享属性的钩子——proto"><a href="#访问共享属性的钩子——proto" class="headerlink" title="访问共享属性的钩子——proto"></a>访问共享属性的钩子——<strong>proto</strong></h2><p>前面已经提到了，通过<strong>proto</strong>对象中可以访问到同类对象的共享属性，比如对象a中并没有直接包含run()方法，但是a.<strong>proto</strong>中包含run()方法，这样当用到a.run()时，js引擎在a的直接属性中未找到该方法，则自动会去a.<strong>proto</strong>中寻找该方法属性，如果依然找不到该方法，则继续去下一层a.<strong>proto</strong>.<strong>proto</strong>寻找该方法，直到某一层的<strong>proto</strong>未undefined为止，利用这个特性，完全可以对一个对象做多层抽象到多个<strong>proto</strong>中，如上例中的学生类的共享属性中包含run(),study(),gotoschool()，toString(),valueOf()方法，完全可以把run(),toString(),valueOf()抽象成一个共享属性对象，为People类使用，因为这些方法属性都是人类的共有特性，进而再把toString(),valueOf()抽象成一个共享属性对象，为Object类使用，即所有的对象所共有的特性。</p>
<h3 id="proto属性是所有对象与生具来的属性"><a href="#proto属性是所有对象与生具来的属性" class="headerlink" title="proto属性是所有对象与生具来的属性"></a><strong>proto</strong>属性是所有对象与生具来的属性</h3><p>我们已经知道，通过<strong>proto</strong>属性可以访问到对象所属类的共享属性，那么这个属性到底来自哪里？总不能每次新建一个对象的时候都要我们手动为<strong>proto</strong>属性来赋值吧？不用担心，来看一下就好了~<br>创建对象的方式有两种，一种是直接用对象字面量来创建，一种是用构造函数法来创建，我们分别看一下这两种创建方式创建的对象的属性</p>
<p><div align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/2018/02/24__proto1.png"></div></p>
<p><div align="center">图3 字面量创建法</div></p>
<p><div align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/2018/02/24__proto2.png"></div></p>
<p><div align="center">图4 构造函数创建法</div><br>图三图四可以看出，无论是哪种方式创建的对象，都自带<strong>proto</strong>属性，也就是说一个对象相关的共享属性对象根本无需我们手动指定，它被JS引擎自动赋值给了这个对象的<strong>proto</strong>属性。</p>
<h2 id="共享属性对象的直接生产者——prototype"><a href="#共享属性对象的直接生产者——prototype" class="headerlink" title="共享属性对象的直接生产者——prototype"></a>共享属性对象的直接生产者——prototype</h2><p>目前为止，我们知道，通过一个对象的<strong>proto</strong>属性可以访问到它相关的共享属性对象，那么这个所谓的共享对象到底是什么呢？我们还不得而知。同样的，针对两种方式创建的对象的分别查看一下他们的<strong>proto</strong>属性的详细信息</p>
<p><div align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/2018/02/24__proto3.png"></div></p>
<p><div align="center">图5 <strong>proto</strong>详细信息——字面量创建法</div></p>
<p><div align="center"><img src="http://p4a8bakov.bkt.clouddn.com/image/2018/02/24__proto4.png"></div></p>
<p><div align="center">图6 <strong>proto</strong>详细信息——构造函数创建法</div><br>通过图5，图6的对比可以看出，两种创建方式的<strong>proto</strong>属性好像差距有点大，这是问什么呢？仔细看看，用对象字面量方式创建的对象中的该属性看上去似曾相识？可以在图5中看到，<strong>proto</strong>属性包含toString(),valueOf(),isPropertyOf(),hasOwnProperty()等一系列Object对象的原生方法，那么这里的<strong>proto</strong>属性何Object是不是有什么关系呢？所以~是时候来和Object.prototype属性作一下对比了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//对象字面量方式创建的对象</span><br><span class="line">var a=&#123;name:&apos;lily&apos;,age:17&#125;;</span><br><span class="line">typeof Object;//&quot;function&quot;</span><br><span class="line">console.log(a.__proto__===Object.prototype);//true</span><br><span class="line">//构造方式创建的对象</span><br><span class="line">var Test=function()&#123;&#125;;</span><br><span class="line">typeof Test;//&quot;function&quot;</span><br><span class="line">var b=new Test();</span><br><span class="line">console.log(a.__proto__===Object.prototype);//false</span><br><span class="line">console.log(a.__proto__===Test.prototype);//true</span><br></pre></td></tr></table></figure></p>
<p>首先，从对象字面量方式创建对象的执行的结果来看，对象的<strong>proto</strong>属性是等于Object的prototype属性的，但是在构造方式创建的对象中这个等式却是不成立的，是不是代表<strong>proto</strong>属性和prototype属性没什么必然关系了呢？NoNoNo!继续往下看 <code>console.log(a.__proto__===Test.prototype)</code>这个结果是<code>true</code>的，表示a对象的<strong>proto</strong>和Test的prototype属性建立了<code>等于</code>关系,那这又说明了什么呢？<br>很简单，通过递归可以得出 <code>o.__proto__===Func.prototype</code>这个恒等式，其中<code>o</code>表示任何方式创建的一个对象，<code>Func</code>表示创建这个对象的构造函数,现在是不是可以理解了，该例中b是通过构造函数Test创建的，所以b.<strong>proto</strong>===Test.prototype,而a是字面量对象，字面量对象实际上是JS引擎由Object构造的，所以当然了，a.__proto===Object.prototype</p>
<p>到现在，可以推出<strong>函数的<code>prototype</code>属性实际上才是真正存放共享属性对象的宿主</strong>，关于prototype属性有以下特点：</p>
<ul>
<li>JS引擎为<strong>所有函数</strong>默认生成了prototype属性</li>
<li>prototype属性的值是一个对象</li>
<li>默认的prototype属性对象都自带Constructor属性，且该属性的值是函数本身(注意重新为prototype赋值后Constructor可能不复存在)。</li>
</ul>
<h2 id="proto和prototype的不同意义"><a href="#proto和prototype的不同意义" class="headerlink" title="proto和prototype的不同意义"></a><strong>proto</strong>和prototype的不同意义</h2><p>我们知道，一般情况下，prototype是函数所特有的属性，而<strong>proto</strong>是所有对象都有的属性，但是函数也是对象，所以就有了：默认情况下，所有函数都同时存在<strong>proto</strong>和prototype属性，但是这两个属性的意义是不同的(<strong>proto</strong>表示了创建该函数的函数(一般是Function)提供的共享属性(即Function.prototype),而prototype则是为通过该函数本身创建的其它对象提供共享属性，通常这个属性会被人为覆盖或扩展)，所以一般有<code>函数.__proto__!==函数.prototype</code></p>
<h2 id="特殊的函数——Function"><a href="#特殊的函数——Function" class="headerlink" title="特殊的函数——Function"></a>特殊的函数——Function</h2><p>刚才说到，一般有<code>函数.__proto__!==函数.prototype</code>，但实际上有一个特殊情况，即Function对象本身，它也是一个函数，并且它是创建构造函数的函数，可以很容易的验证<br><code>Function.__proto__===Function.prototype</code>,这个特殊情况不妨这样理解：<br>Function是所有函数的构造函数，所以肯定存在<code>Function.prototype</code>，反过来因为所有函数的构造函数都是Function，所以Function作为函数也不例外，它也应该能理解为通过Function构造函数创建的，所以又Function.<strong>proto</strong>===Function.prototype</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在，可以对<strong>proto</strong>和prototype来个一句话总结了~——函数的prototype和 对象的<strong>proto</strong>属性共同配合，才有了对象的原型链机制，其中<strong>proto</strong>属性是我们层层递归的访问抽象类的共享属性的直接钩子(没有这个属性，JS引擎无法查找一个对象的上一层的共享属性)，而prototype则使得对象能够自动和共享属性对象绑定成为可能(无需我们手动为<strong>proto</strong>属性赋值，通过JS引擎自动将对象的属性<strong>proto</strong>  <em>和创建对象的构造函数的prototype相绑定</em>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Hitobear</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hitobear</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
